{
  "name": "twtg_ds_vb_01_xx",
  "version": "1.0.0",
  "description": "TWTG DS-VB-01-XX LoRaWAN device product. Preconfigured to work with any LNS Thinger plugin.",
  "author": "Thinger.io",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/thinger-io/plugins.git",
    "directory": "twtg-ds-vb-01-xx"
  },
  "metadata": {
    "name": "twtg_ds-vb-01-xx",
    "description": "TWTG DS-VB-01-XX LoRaWAN device product. Preconfigured to work with any LNS Thinger plugin.",
    "image": "assets/vb.png",
    "category": "devices",
    "vendor": "twtg"
  },
  "resources": {
    "products": [
      {
        "description": "TWTG DS-VB-01-XX LoRaWAN device product. Preconfigured to work with any LNS Thinger plugin.",
        "enabled": true,
        "name": "twtg_ds-vb-01-xx",
        "product": "twtg_ds_vb_01_xx",
        "profile": {
          "api": {
            "downlink": {
              "enabled": true,
              "handle_connectivity": false,
              "request": {
                "data": {
                  "path": "/downlink",
                  "payload": "{\n    \"data\"    : \"{{payload.data=\"\"}}\",\n    \"port\"    :  {{payload.port=85}},\n    \"priority\":  {{payload.priority=3}},\n    \"confirmed\" :  {{payload.confirmed=false}},\n    \"uplink\"  :  {{property.uplink}} \n}",
                  "payload_function": "",
                  "payload_type": "",
                  "plugin": "{{property.uplink.source}}",
                  "target": "plugin_endpoint"
                }
              }
            },
            "uplink": {
              "device_id_resolver": "getId",
              "enabled": true,
              "handle_connectivity": true,
              "request": {
                "data": {
                  "payload": "{{payload}}",
                  "payload_function": "",
                  "payload_type": "source_payload",
                  "resource_stream": "uplink",
                  "target": "resource_stream"
                }
              }
            }
          },
          "autoprovisions": {
            "device_autoprovisioning": {
              "config": {
                "mode": "pattern",
                "pattern": "twtg-ds-vb-01.*"
              },
              "enabled": true
            }
          },
          "buckets": {
            "ds_vb_01_xx_data_bucket": {
              "backend": "mongodb",
              "data": {
                "payload": "{{payload}}",
                "payload_function": "decodeThingerUplink",
                "payload_type": "source_payload",
                "resource": "uplink",
                "source": "resource",
                "update": "events"
              },
              "enabled": true,
              "retention": {
                "period": 3,
                "unit": "months"
              },
              "tags": []
            }
          },
          "code": {
            "code": "function decodeThingerUplink(thingerData) {\n    // 0. If data has already been decoded, we will return it\n    if (thingerData.decodedPayload) return thingerData.decodedPayload;\n    \n    // 1. Extract and Validate Input\n    // We need 'payload' (hex string) and 'fPort' (integer)\n    const hexPayload = thingerData.payload || \"\";\n    const port = thingerData.fPort || 1;\n\n    // 2. Convert Hex String to Byte Array\n    const bytes = [];\n    for (let i = 0; i < hexPayload.length; i += 2) {\n        bytes.push(parseInt(hexPayload.substr(i, 2), 16));\n    }\n\n    // 3. Dynamic Function Detection and Execution\n    \n    // CASE A: (The Things Stack v3)\n    if (typeof decodeUplink === 'function') {\n        try {\n            const input = {\n                bytes: bytes,\n                fPort: port\n            };\n            var result = decodeUplink(input);\n            \n            // PEQUEÑA MEJORA: TTN v3 suele devolver { data: {...}, warnings: [] }\n            // Si quieres devolver solo los datos \"limpios\" a Thinger, descomenta la siguiente línea:\n            // if (result.data) return result.data;\n\n            return result; \n        } catch (e) {\n            console.error(\"Error inside decodeUplink:\", e);\n            throw e;\n        }\n    }\n\n    // CASE B: Legacy TTN (v2)\n    else if (typeof Decoder === 'function') {\n        try {\n            return Decoder(bytes, port);\n        } catch (e) {\n            console.error(\"Error inside Decoder:\", e);\n            throw e;\n        }\n    }\n\n    // CASE C: No decoder found\n    else {\n        throw new Error(\"No compatible TTN decoder function (decodeUplink or Decoder) found in scope.\");\n    }\n}\n\n\n// TTN decoder\n/**\n * Filename          : decoder_vb_doc-E_rev-4.js\n * Latest commit     : 8d3d992e\n * Protocol document : E\n *\n * Release History\n *\n * 2021-04-14 revision 0\n * - initial version\n *\n * 2021-03-05 revision 1\n * - using scientific notation for sensor data scale\n *\n * 2021-05-14 revision 2\n * - made it compatible with v1 and v2 (merged in protocol v1)\n * - added DecodeHexString to directly decode from HEX string\n *\n * 2021-07-15 revision 3\n * - Verify message length with expected_length before parsing\n *\n * 2021-10-27 revision 4\n * - Fixed range check of start_frequency\n *\n * YYYY-MM-DD revision X\n * -\n */\n\nif (typeof module !== 'undefined') {\n  // Only needed for nodejs\n  module.exports = {\n    Decode: Decode,\n    Decoder: Decoder,\n    DecodeHexString: DecodeHexString,\n    DecodeRebootInfo: DecodeRebootInfo,\n    decode_float: decode_float,\n    decode_uint32: decode_uint32,\n    decode_int32: decode_int32,\n    decode_uint16: decode_uint16,\n    decode_int16: decode_int16,\n    decode_uint8: decode_uint8,\n    decode_int8: decode_int8,\n    decode_device_id: decode_device_id,\n    decode_reboot_info: decode_reboot_info,\n    decode_sensor_data_config: decode_sensor_data_config,\n    from_hex_string: from_hex_string\n  };\n}\n\n/**\n * Decoder for Chirpstack (loraserver) network server\n *\n * Decode an uplink message from a buffer\n * (array) of bytes to an object of fields.\n */\nfunction Decode(fPort, bytes) { // Used for ChirpStack (aka LoRa Network Server)\n  var decoded = {};\n  decoded.header = {};\n  decoded.header.protocol_version = bytes[0] >> 4;\n  message_type = bytes[0] & 0x0F;\n\n  var PROTOCOL_VERSION_V1 = 1;\n  var PROTOCOL_VERSION_V2 = 2;\n\n  var MSGID_BOOT = 0;\n  var MSGID_ACTIVATED = 1;\n  var MSGID_DEACTIVATED = 2;\n  var MSGID_SENSOR_EVENT = 3;\n  var MSGID_DEVICE_STATUS = 4;\n  var MSGID_SENSOR_DATA = 8;\n\n  switch (decoded.header.protocol_version) {\n    case PROTOCOL_VERSION_V1:\n    case PROTOCOL_VERSION_V2:\n      {\n        decoded.header.message_type = message_type_lookup(message_type);\n\n        var cursor = {};   // keeping track of which byte to process.\n        cursor.value = 1;  // skip header that has been checked\n\n        switch (message_type) {\n          case MSGID_BOOT: {\n            decoded.boot = decode_boot_msg(bytes, cursor);\n            break;\n          }\n\n          case MSGID_ACTIVATED: {\n            decoded.activated = decode_activated_msg(bytes, cursor);\n            break;\n          }\n\n          case MSGID_DEACTIVATED: {\n            decoded.deactivated = decode_deactivated_msg(bytes, cursor);\n            break;\n          }\n\n          case MSGID_SENSOR_EVENT: {\n            decoded.sensor_event = decode_sensor_event_msg(bytes, cursor);\n            break;\n          }\n\n          case MSGID_DEVICE_STATUS: {\n            decoded.device_status = decode_device_status_msg(bytes, cursor);\n            break;\n          }\n\n          case MSGID_SENSOR_DATA: {\n            decoded.sensor_data = decode_sensor_data_msg(bytes, cursor, decoded.header.protocol_version);\n            break;\n          }\n\n          default:\n            throw \"Invalid message type!\";\n        }\n        break;\n      }\n    default:\n      throw \"Unsupported protocol version!\";\n  }\n\n  return decoded;\n}\n\n\n/**\n * Decoder for reboot payload\n *\n */\nfunction DecodeRebootInfo(reboot_type, bytes) {\n  var cursor = {};   // keeping track of which byte to process.\n  cursor.value = 0;  // skip header that has been checked\n\n  return decode_reboot_info(reboot_type, bytes, cursor);\n}\n\n/**\n * Decoder for The Things Network network server\n */\nfunction Decoder(obj, fPort) {\n  return Decode(fPort, obj);\n}\n\n/** \n * New Decoder for The Things Stack\n */\nfunction decodeUplink(input) {\n  try {\n    obj = Decode(input.fPort, input.bytes);\n    return {\n      data: obj\n    }\n  }\n  catch (e) {\n    return {\n      errors: [e.toString()]\n    };\n\n  }\n}\n\n/**\n * Decoder for plain HEX string\n */\nfunction DecodeHexString(hex_string) {\n  return Decode(15, from_hex_string(hex_string));\n}\n\n/******************\n * Helper functions\n */\n\n// helper function to convert a ASCII HEX string to a byte string\nfunction from_hex_string(hex_string) {\n  if (typeof hex_string != \"string\") throw new Error(\"hex_string must be a string\");\n  if (!hex_string.match(/^[0-9A-F]*$/gi)) throw new Error(\"hex_string contain only 0-9, A-F characters\");\n  if (hex_string.length & 0x01 > 0) throw new Error(\"hex_string length must be a multiple of two\");\n\n  var byte_string = [];\n  for (i = 0; i < hex_string.length; i += 2) {\n    var hex = hex_string.slice(i, i + 2);\n    byte_string.push(parseInt(hex, 16));\n  }\n  return byte_string;\n}\n\n// pad zeros on decimal number\nfunction pad(num, size) {\n  num = num.toString();\n  while (num.length < size) num = \"0\" + num;\n  return num;\n}\n\n// helper function to parse an 32 bit float\nfunction decode_float(bytes, cursor) {\n  // JavaScript bitwise operators yield a 32 bits integer, not a float.\n  // Assume LSB (least significant byte first).\n  var bits = decode_int32(bytes, cursor);\n  var sign = (bits >>> 31 === 0) ? 1.0 : -1.0;\n  var e = bits >>> 23 & 0xff;\n  if (e == 0xFF) {\n    if (bits & 0x7fffff) {\n      return NaN;\n    } else {\n      return sign * Infinity;\n    }\n  }\n  var m = (e === 0) ? (bits & 0x7fffff) << 1 : (bits & 0x7fffff) | 0x800000;\n  var f = sign * m * Math.pow(2, e - 150);\n  return f;\n}\n\n// helper function to parse an unsigned uint32\nfunction decode_uint32(bytes, cursor) {\n  var result = 0;\n  var i = cursor.value + 3;\n  result = bytes[i--];\n  result = result * 256 + bytes[i--];\n  result = result * 256 + bytes[i--];\n  result = result * 256 + bytes[i--];\n  cursor.value += 4;\n\n  return result;\n}\n\n// helper function to parse an unsigned int32\nfunction decode_int32(bytes, cursor) {\n  var result = 0;\n  var i = cursor.value + 3;\n  result = (result << 8) | bytes[i--];\n  result = (result << 8) | bytes[i--];\n  result = (result << 8) | bytes[i--];\n  result = (result << 8) | bytes[i--];\n  cursor.value += 4;\n\n  return result;\n}\n\n// helper function to parse an unsigned uint16\nfunction decode_uint16(bytes, cursor) {\n  var result = 0;\n  var i = cursor.value + 1;\n  result = bytes[i--];\n  result = result * 256 + bytes[i--];\n  cursor.value += 2;\n\n  return result;\n}\n\n// helper function to parse a signed int16\nfunction decode_int16(bytes, cursor) {\n  var result = 0;\n  var i = cursor.value + 1;\n  if (bytes[i] & 0x80) {\n    result = 0xFFFF;\n  }\n  result = (result << 8) | bytes[i--];\n  result = (result << 8) | bytes[i--];\n  cursor.value += 2;\n\n  return result;\n}\n\n// helper function to parse an unsigned int8\nfunction decode_uint8(bytes, cursor) {\n  var result = bytes[cursor.value];\n  cursor.value += 1;\n\n  return result;\n}\n\n// helper function to parse an unsigned int8\nfunction decode_int8(bytes, cursor) {\n  var result = 0;\n  var i = cursor.value;\n  if (bytes[i] & 0x80) {\n    result = 0xFFFFFF;\n  }\n  result = (result << 8) | bytes[i--];\n  cursor.value += 1;\n\n  return result;\n}\n\n// helper function to parse device_id\nfunction decode_device_id(bytes, cursor) {\n  // bytes[0]\n  var prefix = decode_uint8(bytes, cursor).toString();\n\n  // bytes[1..5]\n  var serial = pad(decode_uint32(bytes, cursor), 10);\n\n  var device_id = prefix + \"-\" + serial;\n\n  return device_id;\n}\n\n// helper function to parse fft config in sensor_data\nfunction decode_sensor_data_config(bytes, cursor, protocol_version) {\n  config = decode_uint32(bytes, cursor);\n  var result = {};\n\n  // bits[0..7]\n  result.frame_number = config & 0xFF;\n\n  // bits[8..9]\n  result.sequence_number = (config >> 8) & 0x03;\n\n  // bits[10..11]\n  result.axis = \"\";\n  switch ((config >> 10) & 0x3) {\n    case 0:\n      result.axis = \"x\";\n      break;\n    case 1:\n      result.axis = \"y\";\n      break;\n    case 2:\n      result.axis = \"z\";\n      break;\n    default:\n      throw \"Invalid axis value in sensor data config!\";\n  }\n\n  // bits[12]\n  switch ((config >> 12) & 0x1) {\n    case 0:\n      result.unit = \"velocity\";\n      break;\n    case 1:\n    default:\n      result.unit = \"acceleration\";\n      break;\n  }\n\n  switch (protocol_version) {\n    case 1:\n      // bits[13..18]\n      result.scale = ((config >> 13) & 0x3F) * 4;\n      if (result.scale == 0) {\n        throw \"Invalid config.scale value!\"\n      }\n      break;\n\n    case 2:\n      // bits[13..16]\n      var scale_coefficient = ((config >> 13) & 0x0F);\n      if (scale_coefficient < 1 || scale_coefficient > 15) {\n        throw \"Invalid config.scale coefficient value!\"\n      }\n      // bits[17..18]\n      var scale_power = ((config >> 17) & 0x03) - 2;\n      result.scale = scale_coefficient * Math.pow(10, scale_power);\n      break;\n\n    default:\n      throw \"Unsupported protocol version!\";\n  }\n\n  // bits[19..31]\n  result.start_frequency = config >>> 19;\n  if (result.start_frequency < 0 || result.start_frequency > 8191) {\n    throw \"Invalid start_frequency value in sensor data config!\";\n  }\n\n  // bytes[5]\n  result.spectral_line_frequency = decode_uint8(bytes, cursor);\n  if (result.spectral_line_frequency == 0) {\n    throw \"Invalid spectral_line_frequency value in sensor data config!\";\n  }\n\n\n  return result;\n}\n\n// helper function to parse reboot_info\nfunction decode_reboot_info(reboot_type, bytes, cursor) {\n  var result;\n\n  var reboot_payload = [0, 0, 0, 0, 0, 0, 0, 0];\n  reboot_payload[0] += decode_uint8(bytes, cursor);\n  reboot_payload[1] += decode_uint8(bytes, cursor);\n  reboot_payload[2] += decode_uint8(bytes, cursor);\n  reboot_payload[3] += decode_uint8(bytes, cursor);\n  reboot_payload[4] += decode_uint8(bytes, cursor);\n  reboot_payload[5] += decode_uint8(bytes, cursor);\n  reboot_payload[6] += decode_uint8(bytes, cursor);\n  reboot_payload[7] += decode_uint8(bytes, cursor);\n\n  switch (reboot_type) {\n    case 0: // REBOOT_INFO_TYPE_NONE\n      result = 'none';\n      break;\n\n    case 1: // REBOOT_INFO_TYPE_POWER_CYCLE\n      result = 'power cycle';\n      break;\n\n    case 2: // REBOOT_INFO_TYPE_WDOG\n      result = 'swdog (' + String.fromCharCode(\n        reboot_payload[0],\n        reboot_payload[1],\n        reboot_payload[2],\n        reboot_payload[3]).replace(/[^\\x20-\\x7E]/g, '') + ')';\n\n      break;\n\n    case 3: // REBOOT_INFO_TYPE_ASSERT\n      var payloadCursor = {}; // keeping track of which byte to process.\n      payloadCursor.value = 4; // skip caller address\n      actualValue = decode_int32(reboot_payload, payloadCursor);\n      result = 'assert (' +\n        'caller: 0x' +\n        uint8_to_hex(reboot_payload[3]) +\n        uint8_to_hex(reboot_payload[2]) +\n        uint8_to_hex(reboot_payload[1]) +\n        uint8_to_hex(reboot_payload[0]) +\n        '; value: ' + actualValue.toString() + ')';\n      break;\n\n    case 4: // REBOOT_INFO_TYPE_APPLICATION_REASON\n      result = 'application (0x' +\n        uint8_to_hex(reboot_payload[3]) +\n        uint8_to_hex(reboot_payload[2]) +\n        uint8_to_hex(reboot_payload[1]) +\n        uint8_to_hex(reboot_payload[0]) + ')';\n      break;\n\n    case 5: // REBOOT_INFO_TYPE_SYSTEM_ERROR\n      result = 'system (error: 0x' +\n        uint8_to_hex(reboot_payload[3]) +\n        uint8_to_hex(reboot_payload[2]) +\n        uint8_to_hex(reboot_payload[1]) +\n        uint8_to_hex(reboot_payload[0]) +\n        '; caller: 0x' +\n        uint8_to_hex(reboot_payload[7]) +\n        uint8_to_hex(reboot_payload[6]) +\n        uint8_to_hex(reboot_payload[5]) +\n        uint8_to_hex(reboot_payload[4]) + ')';\n      break;\n\n    default:\n      result = 'unknown (' +\n        '0x' + uint8_to_hex(reboot_payload[0]) + ', ' +\n        '0x' + uint8_to_hex(reboot_payload[1]) + ', ' +\n        '0x' + uint8_to_hex(reboot_payload[2]) + ', ' +\n        '0x' + uint8_to_hex(reboot_payload[3]) + ', ' +\n        '0x' + uint8_to_hex(reboot_payload[4]) + ', ' +\n        '0x' + uint8_to_hex(reboot_payload[5]) + ', ' +\n        '0x' + uint8_to_hex(reboot_payload[6]) + ', ' +\n        '0x' + uint8_to_hex(reboot_payload[7]) + ')';\n      break;\n  }\n\n  return result;\n}\n\nfunction uint8_to_hex(d) {\n  return ('0' + (Number(d).toString(16).toUpperCase())).slice(-2);\n}\n\nfunction uint16_to_hex(d) {\n  return ('000' + (Number(d).toString(16).toUpperCase())).slice(-4);\n}\n\nfunction uint32_to_hex(d) {\n  return ('0000000' + (Number(d).toString(16).toUpperCase())).slice(-8);\n}\n\nfunction message_type_lookup(type_id) {\n  type_names = [\"boot\",\n    \"activated\",\n    \"deactivated\",\n    \"sensor_event\",\n    \"device_status\",\n    \"base_configuration\",\n    \"sensor_configuration\",\n    \"sensor_data_configuration\",\n    \"sensor_data\"];\n  if (type_id < type_names.length) {\n    return type_names[type_id];\n  } else {\n    return \"unknown\";\n  }\n}\n\nfunction device_types_lookup(type_id) {\n  type_names = [\"\", // reserved\n    \"ts\",\n    \"vs-qt\",\n    \"vs-mt\",\n    \"tt\",\n    \"ld\",\n    \"vb\"];\n  if (type_id < type_names.length) {\n    return type_names[type_id];\n  } else {\n    return \"unknown\";\n  }\n}\n\nfunction trigger_lookup(trigger_id) {\n  switch (trigger_id) {\n    case 0:\n      return \"timer\";\n    case 1:\n      return \"button\";\n    case 2:\n      return \"condition_0\";\n    case 3:\n      return \"condition_1\";\n    case 4:\n      return \"condition_2\";\n    case 5:\n      return \"condition_3\";\n    case 6:\n      return \"condition_4\";\n    case 7:\n      return \"condition_5\";\n    default:\n      return \"unknown\";\n  }\n}\n\nfunction deactivation_reason_lookup(deactivation_id) {\n  switch (deactivation_id) {\n    case 0:\n      return \"user_triggered\";\n    case 1:\n      return \"activation_user_timeout\";\n    case 2:\n      return \"activation_sensor_comm_fail\";\n    case 3:\n      return \"activation_sensor_meas_fail\";  // VB does not have it\n    default:\n      return \"unknown\";\n  }\n}\n\nObject.prototype.in = function () {\n  for (var i = 0; i < arguments.length; i++)\n    if (arguments[i] == this) return true;\n  return false;\n}\n\n/***************************\n * Message decoder functions\n */\n\nfunction decode_boot_msg(bytes, cursor) {\n  var boot = {};\n\n  var expected_length = 46;\n  if (bytes.length != expected_length) {\n    throw \"Invalid boot message length \" + bytes.length + \" instead of \" + expected_length\n  }\n\n  boot.base = {};\n  // byte[1]\n  var device_type = decode_uint8(bytes, cursor);\n  boot.base.device_type = device_types_lookup(device_type);\n\n  // byte[2..5]\n  var version_hash = decode_uint32(bytes, cursor);\n  boot.base.version_hash = '0x' + uint32_to_hex(version_hash);\n\n  // byte[6..7]\n  var config_crc = decode_uint16(bytes, cursor);\n  boot.base.config_crc = '0x' + uint16_to_hex(config_crc);\n\n  // byte[8]\n  var reset_flags = decode_uint8(bytes, cursor);\n  boot.base.reset_flags = '0x' + uint8_to_hex(reset_flags);\n\n  // byte[9]\n  boot.base.reboot_counter = decode_uint8(bytes, cursor);\n\n  // byte[10]\n  base_reboot_type = decode_uint8(bytes, cursor);\n\n  // byte[11..18]\n  boot.base.reboot_info = decode_reboot_info(base_reboot_type, bytes, cursor);\n\n  // byte[19]\n  var bist = decode_uint8(bytes, cursor);\n  boot.base.bist = '0x' + uint8_to_hex(bist);\n\n  boot.sensor = {};\n  // byte[20]\n  var device_type = decode_uint8(bytes, cursor);\n  boot.sensor.device_type = device_types_lookup(device_type);\n\n  // byte[21..25]\n  boot.sensor.device_id = decode_device_id(bytes, cursor);\n\n  // byte[26..29]\n  var version_hash = decode_uint32(bytes, cursor);\n  boot.sensor.version_hash = '0x' + uint32_to_hex(version_hash);\n\n  // byte[30..31]\n  var config_crc = decode_uint16(bytes, cursor);\n  boot.sensor.config_crc = '0x' + uint16_to_hex(config_crc);\n\n  // byte[32..33]\n  var data_config_crc = decode_uint16(bytes, cursor);\n  boot.sensor.data_config_crc = '0x' + uint16_to_hex(data_config_crc);\n\n  // byte[34]\n  var reset_flags = decode_uint8(bytes, cursor);\n  boot.sensor.reset_flags = '0x' + uint8_to_hex(reset_flags);\n\n  // byte[35]\n  boot.sensor.reboot_counter = decode_uint8(bytes, cursor);\n\n  // byte[36]\n  sensor_reboot_type = decode_uint8(bytes, cursor);\n\n  // byte[37..44]\n  boot.sensor.reboot_info = decode_reboot_info(sensor_reboot_type, bytes, cursor);\n\n  // byte[45]\n  var bist = decode_uint8(bytes, cursor);\n  boot.sensor.bist = '0x' + uint8_to_hex(bist);\n\n  return boot;\n}\n\nfunction decode_activated_msg(bytes, cursor) {\n  var activated = {};\n\n  var expected_length = 7;\n  if (bytes.length != expected_length) {\n    throw \"Invalid activated message length \" + bytes.length + \" instead of \" + expected_length\n  }\n\n  activated.sensor = {};\n\n  // byte[1]\n  var device_type = decode_uint8(bytes, cursor);\n  activated.sensor.device_type = device_types_lookup(device_type);\n\n  // byte[2..6]\n  activated.sensor.device_id = decode_device_id(bytes, cursor);\n\n  return activated;\n}\n\nfunction decode_deactivated_msg(bytes, cursor) {\n  var deactivated = {};\n\n  var expected_length = 3;\n  if (bytes.length != expected_length) {\n    throw \"Invalid deactivated message length \" + bytes.length + \" instead of \" + expected_length\n  }\n\n  // byte[1]\n  var reason = decode_uint8(bytes, cursor);\n  deactivated.reason = deactivation_reason_lookup(reason);\n\n  // byte[2]\n  var reason_length = decode_uint8(bytes, cursor);\n\n  if (reason_length != 0) {\n    throw \"Unsupported deactivated reason length\"\n  }\n\n  return deactivated;\n}\n\nfunction decode_sensor_event_msg(bytes, cursor) {\n  var sensor_event = {};\n\n  var expected_length = 45;\n  if (bytes.length != expected_length) {\n    throw \"Invalid sensor_event message length \" + bytes.length + \" instead of \" + expected_length\n  }\n\n  // byte[1]\n  trigger = decode_uint8(bytes, cursor);\n  sensor_event.trigger = trigger_lookup(trigger);\n\n  sensor_event.rms_velocity = {};\n\n  // byte[2..7]\n  sensor_event.rms_velocity.x = {};\n  sensor_event.rms_velocity.x.min = decode_uint16(bytes, cursor) / 100;\n  sensor_event.rms_velocity.x.max = decode_uint16(bytes, cursor) / 100;\n  sensor_event.rms_velocity.x.avg = decode_uint16(bytes, cursor) / 100;\n\n  // byte[8..13]\n  sensor_event.rms_velocity.y = {};\n  sensor_event.rms_velocity.y.min = decode_uint16(bytes, cursor) / 100;\n  sensor_event.rms_velocity.y.max = decode_uint16(bytes, cursor) / 100;\n  sensor_event.rms_velocity.y.avg = decode_uint16(bytes, cursor) / 100;\n\n  // byte[14..19]\n  sensor_event.rms_velocity.z = {};\n  sensor_event.rms_velocity.z.min = decode_uint16(bytes, cursor) / 100;\n  sensor_event.rms_velocity.z.max = decode_uint16(bytes, cursor) / 100;\n  sensor_event.rms_velocity.z.avg = decode_uint16(bytes, cursor) / 100;\n\n  sensor_event.acceleration = {};\n\n  // byte[20..25]\n  sensor_event.acceleration.x = {};\n  sensor_event.acceleration.x.min = decode_int16(bytes, cursor) / 100;\n  sensor_event.acceleration.x.max = decode_int16(bytes, cursor) / 100;\n  sensor_event.acceleration.x.avg = decode_int16(bytes, cursor) / 100;\n\n  // byte[26..31]\n  sensor_event.acceleration.y = {};\n  sensor_event.acceleration.y.min = decode_int16(bytes, cursor) / 100;\n  sensor_event.acceleration.y.max = decode_int16(bytes, cursor) / 100;\n  sensor_event.acceleration.y.avg = decode_int16(bytes, cursor) / 100;\n\n  // byte[32..37]\n  sensor_event.acceleration.z = {};\n  sensor_event.acceleration.z.min = decode_int16(bytes, cursor) / 100;\n  sensor_event.acceleration.z.max = decode_int16(bytes, cursor) / 100;\n  sensor_event.acceleration.z.avg = decode_int16(bytes, cursor) / 100;\n\n  // byte[38..43]\n  sensor_event.temperature = {};\n  sensor_event.temperature.min = decode_int16(bytes, cursor) / 100;\n  sensor_event.temperature.max = decode_int16(bytes, cursor) / 100;\n  sensor_event.temperature.avg = decode_int16(bytes, cursor) / 100;\n\n  // byte[44]\n  var conditions = decode_uint8(bytes, cursor);\n  sensor_event.condition_0 = (conditions & 1);\n  sensor_event.condition_1 = ((conditions >> 1) & 1);\n  sensor_event.condition_2 = ((conditions >> 2) & 1);\n  sensor_event.condition_3 = ((conditions >> 3) & 1);\n  sensor_event.condition_4 = ((conditions >> 4) & 1);\n  sensor_event.condition_5 = ((conditions >> 5) & 1);\n\n  return sensor_event;\n}\n\nfunction decode_device_status_msg(bytes, cursor) {\n  var device_status = {};\n\n  var expected_length = 24;\n  if (bytes.length != expected_length) {\n    throw \"Invalid device_status message length \" + bytes.length + \" instead of \" + expected_length\n  }\n\n  device_status.base = {};\n  device_status.sensor = {};\n\n  // byte[1..2]\n  var config_crc = decode_uint16(bytes, cursor);\n  device_status.base.config_crc = '0x' + uint16_to_hex(config_crc);\n\n  // byte[3..8]\n  device_status.base.battery_voltage = {}\n  device_status.base.battery_voltage.low = decode_uint16(bytes, cursor) / 1000.0;\n  device_status.base.battery_voltage.high = decode_uint16(bytes, cursor) / 1000.0;\n  device_status.base.battery_voltage.settle = decode_uint16(bytes, cursor) / 1000.0;\n\n  // byte[9..11]\n  device_status.base.temperature = {}\n  device_status.base.temperature.min = decode_int8(bytes, cursor);\n  device_status.base.temperature.max = decode_int8(bytes, cursor);\n  device_status.base.temperature.avg = decode_int8(bytes, cursor);\n\n  // byte[12]\n  device_status.base.lvds_error_counter = decode_uint8(bytes, cursor);\n\n  // byte[13..15]\n  device_status.base.lora_tx_counter = decode_uint8(bytes, cursor);\n  device_status.base.avg_rssi = -decode_uint8(bytes, cursor);\n  device_status.base.avg_snr = decode_int8(bytes, cursor);\n\n  // byte[16]\n  var bist = decode_uint8(bytes, cursor);\n  device_status.base.bist = '0x' + uint8_to_hex(bist);\n\n  // byte[17]\n  var device_type = decode_uint8(bytes, cursor);\n  device_status.sensor.device_type = device_types_lookup(device_type);\n\n  // byte[18..19]\n  var config_crc = decode_uint16(bytes, cursor);\n  device_status.sensor.config_crc = '0x' + uint16_to_hex(config_crc);\n\n  // byte[20..21]\n  var data_config_crc = decode_uint16(bytes, cursor);\n  device_status.sensor.data_config_crc = '0x' + uint16_to_hex(data_config_crc);\n\n  // byte[22]\n  device_status.sensor.event_counter = decode_uint8(bytes, cursor);\n\n  // byte[23]\n  var bist = decode_uint8(bytes, cursor);\n  device_status.sensor.bist = '0x' + uint8_to_hex(bist);\n\n  return device_status;\n}\n\nfunction decode_sensor_data_msg(bytes, cursor, protocol_version) {\n  var sensor_data = {};\n\n  var expected_length = 46;\n  if (bytes.length != expected_length) {\n    throw \"Invalid sensor_data message length \" + bytes.length + \" instead of \" + expected_length\n  }\n\n  // byte[1..5]\n  sensor_data.config = decode_sensor_data_config(bytes, cursor, protocol_version);\n\n  // byte[6..45]\n  sensor_data.raw = [];\n  while (cursor.value < bytes.length) {\n    sensor_data.raw[cursor.value - 6] = bytes[cursor.value];\n\n    cursor.value += 1;\n  }\n\n  // Process raw data\n  sensor_data.frequency = [];\n  sensor_data.magnitude = [];\n\n  // convert from bin to Hz\n  var binToHzFactor = 1.62762;\n  for (i = 0; i < 40; i++) {\n    sensor_data.frequency[i] = sensor_data.config.start_frequency * binToHzFactor +\n      (sensor_data.config.frame_number * 40 * sensor_data.config.spectral_line_frequency * binToHzFactor) +\n      (i * sensor_data.config.spectral_line_frequency * binToHzFactor);\n    sensor_data.magnitude[i] = sensor_data.raw[i] * sensor_data.config.scale / 255;\n    sensor_data.frequency[i] = sensor_data.frequency[i];\n  }\n\n  return sensor_data;\n}",
            "environment": "javascript",
            "storage": "",
            "version": "1.0"
          },
          "properties": {
            "uplink": {
              "data": {
                "payload": "{{payload}}",
                "payload_function": "",
                "payload_type": "source_payload",
                "resource": "uplink",
                "source": "resource",
                "update": "events"
              },
              "default": {
                "source": "value"
              },
              "enabled": true
            }
          }
        },
        "_resources": {
          "properties": []
        }
      }
    ]
  }
}