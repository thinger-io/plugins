{
  "name": "sensative_strips",
  "version": "1.0.0",
  "description": "Strips multisensor by Sensative AB",
  "author": "Thinger.io",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/thinger-io/plugins.git",
    "directory": "sensative-strips"
  },
  "metadata": {
    "name": "Sensative STRIPS",
    "description": "Strips multisensor by Sensative AB",
    "image": "assets/strip.png",
    "category": "devices",
    "vendor": "sensative"
  },
  "resources": {
    "products": [
      {
        "description": "Strips multisensor by Sensative AB",
        "enabled": true,
        "name": "Sensative STRIPS",
        "product": "sensative_strips",
        "profile": {
          "code": {
            "code": "function decodeThingerUplink(thingerData) {\n    // 0. If data has already been decoded, we will return it\n    if (thingerData.decodedPayload) return thingerData.decodedPayload;\n    \n    // 1. Extract and Validate Input\n    // We need 'payload' (hex string) and 'fPort' (integer)\n    const hexPayload = thingerData.payload || \"\";\n    const port = thingerData.fPort || 1;\n\n    // 2. Convert Hex String to Byte Array\n    const bytes = [];\n    for (let i = 0; i < hexPayload.length; i += 2) {\n        bytes.push(parseInt(hexPayload.substr(i, 2), 16));\n    }\n\n    // 3. Dynamic Function Detection and Execution\n    \n    // CASE A: (The Things Stack v3)\n    if (typeof decodeUplink === 'function') {\n        try {\n            const input = {\n                bytes: bytes,\n                fPort: port\n            };\n            var result = decodeUplink(input);\n            \n            if (result.data) return result.data;\n\n            return result; \n        } catch (e) {\n            console.error(\"Error inside decodeUplink:\", e);\n            throw e;\n        }\n    }\n\n    // CASE B: Legacy TTN (v2)\n    else if (typeof Decoder === 'function') {\n        try {\n            return Decoder(bytes, port);\n        } catch (e) {\n            console.error(\"Error inside Decoder:\", e);\n            throw e;\n        }\n    }\n\n    // CASE C: No decoder found\n    else {\n        throw new Error(\"No compatible TTN decoder function (decodeUplink or Decoder) found in scope.\");\n    }\n}\n\n\n// TTN decoder\nfunction Decoder(bytes, port) {\n\t// Decode an uplink message from a buffer\n\t// (array) of bytes to an object of fields.\n\t\n\tfunction decodeFrame(type, target)\n\t{\n\t\tswitch(type & 0x7f) {\n\t\t\tcase 0:\n\t\t\t\ttarget.emptyFrame = {};\n\t\t\t\tbreak;\n\t\t\tcase 1: // Battery 1byte 0-100%\n\t\t\t\ttarget.battery = {};\n\t\t\t\ttarget.battery = bytes[pos++];\n\t\t\t\tbreak;\n\t\t\tcase 2: // TempReport 2bytes 0.1degree C\n\t\t\t\ttarget.temperature = {}; // celcius 0.1 precision\n\t\t\t\ttarget.temperature.value = ((bytes[pos] & 0x80 ? 0xFFFF<<16 : 0) | (bytes[pos++] << 8) | bytes[pos++]) / 10;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// Temp alarm\n\t\t\t\ttarget.tempAlarm = {};  // sends alarm after >x<\n\t\t\t\ttarget.tempAlarm.highAlarm = !!(bytes[pos] & 0x01); // boolean\n\t\t\t\ttarget.tempAlarm.lowAlarm = !!(bytes[pos] & 0x02);  // boolean\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\tcase 4: // AvgTempReport 2bytes 0.1degree C\n\t\t\t\ttarget.averageTemperature = {};\n\t\t\t\ttarget.averageTemperature.value = ((bytes[pos] & 0x80 ? 0xFFFF<<16 : 0) | (bytes[pos++] << 8) | bytes[pos++]) / 10;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\t// AvgTemp alarm\n\t\t\t\ttarget.avgTempAlarm = {}; // sends alarm after >x<\n\t\t\t\ttarget.avgTempAlarm.highAlarm = !!(bytes[pos] & 0x01); // boolean\n\t\t\t\ttarget.avgTempAlarm.lowAlarm = !!(bytes[pos] & 0x02);  // boolean\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\tcase 6: // Humidity 1byte 0-100% in 0.5%\n\t\t\t\ttarget.humidity = {};\n\t\t\t\ttarget.humidity.value = bytes[pos++] / 2; // relativeHumidity percent 0,5\n\t\t\t\tbreak;\n\t\t\tcase 7: // Lux 2bytes 0-65535lux\n\t\t\t\ttarget.lux = {};\n\t\t\t\ttarget.lux.value = ((bytes[pos++] << 8) | bytes[pos++]); // you can  the lux range between two sets (lux1 and 2)\n\t\t\t\tbreak;\n\t\t\tcase 8: // Lux 2bytes 0-65535lux\n\t\t\t\ttarget.lux2 = {};\n\t\t\t\ttarget.lux2.value = ((bytes[pos++] << 8) | bytes[pos++]);\n\t\t\t\tbreak;\n\t\t\tcase 9: // DoorSwitch 1bytes binary\n\t\t\t\ttarget.door = {};\n\t\t\t\ttarget.door.value = !!bytes[pos++]; // false = door open, true = door closed\n\t\t\t\tbreak;\n\t\t\tcase 10: // DoorAlarm 1bytes binary\n\t\t\t\ttarget.doorAlarm = {};\n\t\t\t\ttarget.doorAlarm.value = !!bytes[pos++]; // boolean true = alarm\n\t\t\t\tbreak;\n\t\t\tcase 11: // TamperReport 1bytes binary (was previously TamperSwitch)\n\t\t\t\ttarget.tamperReport = {};\n\t\t\t\ttarget.tamperReport.value = !!bytes[pos++];\n\t\t\t\tbreak;\n\t\t\tcase 12: // TamperAlarm 1bytes binary\n\t\t\t\ttarget.tamperAlarm = {};\n\t\t\t\ttarget.tamperAlarm.value = !!bytes[pos++];\n\t\t\t\tbreak;\n\t\t\tcase 13: // Flood 1byte 0-100%\n\t\t\t\ttarget.flood = {};\n\t\t\t\ttarget.flood.value = bytes[pos++]; // percentage, relative wetness\n\t\t\t\tbreak;\n\t\t\tcase 14: // FloodAlarm 1bytes binary\n\t\t\t\ttarget.floodAlarm = {};\n\t\t\t\ttarget.floodAlarm.value = !!bytes[pos++]; // boolean, after >x<\n\t\t\t\tbreak;\n\t\t\tcase 15: // oilAlarm 1bytes analog\n\t\t\t\ttarget.oilAlarm = {};\n\t\t\t\ttarget.oilAlarm.value = bytes[pos];\n\t\t\t\ttarget.foilAlarm = {}; // Compatibility with older strips\n\t\t\t\ttarget.foilAlarm.value = !!bytes[pos++];\n\t\t\t\tbreak;\n\t\t\tcase 16: // UserSwitch1Alarm, 1 byte digital\n\t\t\t\ttarget.userSwitch1Alarm = {};\n\t\t\t\ttarget.userSwitch1Alarm.value = !!bytes[pos++];\n\t\t\t\tbreak;\n\t\t\tcase 17: // DoorCountReport, 2 byte analog\n\t\t\t\ttarget.doorCount = {};\n\t\t\t\ttarget.doorCount.value = ((bytes[pos++] << 8) | bytes[pos++]);\n\t\t\t\tbreak;\n\t\t\tcase 18: // PresenceReport, 1 byte digital\n\t\t\t\ttarget.presence = {};\n\t\t\t\ttarget.presence.value = !!bytes[pos++];\n\t\t\t\tbreak;\n\t\t\tcase 19: // IRProximityReport\n\t\t\t\ttarget.IRproximity = {};\n\t\t\t\ttarget.IRproximity.value = ((bytes[pos++] << 8) | bytes[pos++]);\n\t\t\t\tbreak;\n\t\t\tcase 20: // IRCloseProximityReport, low power\n\t\t\t\ttarget.IRcloseproximity = {};\n\t\t\t\ttarget.IRcloseproximity.value = ((bytes[pos++] << 8) | bytes[pos++]);\n\t\t\t\tbreak;\n\t\t\tcase 21: // CloseProximityAlarm, something very close to presence sensor\n\t\t\t\ttarget.closeProximityAlarm = {};\n\t\t\t\ttarget.closeProximityAlarm.value = !!bytes[pos++];\n\t\t\t\tbreak;\n\t\t\tcase 22: // DisinfectAlarm\n\t\t\t\ttarget.disinfectAlarm = {};\n\t\t\t\ttarget.disinfectAlarm.value = bytes[pos++];\n\t\t\t\t\tif (target.disinfectAlarm.value === 0) target.disinfectAlarm.state='dirty';\n\t\t\t\t\tif (target.disinfectAlarm.value == 1) target.disinfectAlarm.state='occupied';\n\t\t\t\t\tif (target.disinfectAlarm.value == 2) target.disinfectAlarm.state='cleaning';\n\t\t\t\t\tif (target.disinfectAlarm.value == 3) target.disinfectAlarm.state='clean';\n\t\t\t\tbreak;\n\t\t\tcase 80:\n\t\t\t\ttarget.humidity = {};\n\t\t\t\ttarget.humidity.value = bytes[pos++] / 2;\n\t\t\t\ttarget.temperature = {};\n\t\t\t\ttarget.temperature = ((bytes[pos] & 0x80 ? 0xFFFF<<16 : 0) | (bytes[pos++] << 8) | bytes[pos++]) / 10;\n\t\t\t\tbreak;\n\t\t\tcase 81:\n\t\t\t\ttarget.humidity = {};\n\t\t\t\ttarget.humidity.value = bytes[pos++] / 2;\n\t\t\t\ttarget.averageTemperature = {};\n\t\t\t\ttarget.averageTemperature.value = ((bytes[pos] & 0x80 ? 0xFFFF<<16 : 0) | (bytes[pos++] << 8) | bytes[pos++]) / 10;\n\t\t\t\tbreak;\n\t\t\tcase 82:\n\t\t\t\ttarget.door = {};\n\t\t\t\ttarget.door.value = !!bytes[pos++]; // true = door open, false = door closed\n\t\t\t\ttarget.temperature = {};\n\t\t\t\ttarget.temperature = ((bytes[pos] & 0x80 ? 0xFFFF<<16 : 0) | (bytes[pos++] << 8) | bytes[pos++]) / 10;\n\t\t\t\tbreak;\n\t\t\tcase 112: // Capacitance Raw Sensor Value 2bytes 0-65535\n\t\t\t\ttarget.capacitanceFlood = {};\n\t\t\t\ttarget.capacitanceFlood.value = ((bytes[pos++] << 8) | bytes[pos++]); // should never trigger anymore\n\t\t\t\tbreak;\n\t\t\tcase 113: // Capacitance Raw Sensor Value 2bytes 0-65535\n\t\t\t\ttarget.capacitancePad = {};\n\t\t\t\ttarget.capacitancePad.value = ((bytes[pos++] << 8) | bytes[pos++]); // should never trigger anymore\n\t\t\t\tbreak;\n\t\t\tcase 110:\n\t\t\t\tpos += 8;\n\t\t\t\tbreak;\n\t\t\tcase 114: // Capacitance Raw Sensor Value 2bytes 0-65535\n\t\t\t\ttarget.capacitanceEnd = {};\n\t\t\t\ttarget.capacitanceEnd.value = ((bytes[pos++] << 8) | bytes[pos++]); // should never trigger anymore\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tvar decoded = {};\n\tvar pos = 0;\n\tvar type;\n\t\n\tswitch(port) {\n\t\tcase 1:\n\t\tif(bytes.length < 2) {\n\t\t\tdecoded.error = 'Wrong length of RX package';\n\t\t\tbreak;\n\t\t}\n\t\tdecoded.historySeqNr = (bytes[pos++] << 8) | bytes[pos++];\n\t\tdecoded.prevHistSeqNr = decoded.historySeqNr;\n\t\twhile(pos < bytes.length) {\n\t\t\ttype = bytes[pos++];\n\t\t\tif(type & 0x80)\n\t\t\tdecoded.prevHistSeqNr--;\n\t\t\tdecodeFrame(type, decoded);\n\t\t}\n\t\tbreak;\n\t\t\n\t\tcase 2:\n\t\tvar now = new Date();\n\t\tdecoded.history = {};\n\t\tif(bytes.length < 2) {\n\t\t\tdecoded.history.error = 'Wrong length of RX package';\n\t\t\tbreak;\n\t\t}\t  \n\t\tvar seqNr = (bytes[pos++] << 8) | bytes[pos++];\n\t\twhile(pos < bytes.length) {\n\t\t\tdecoded.history[seqNr] = {};\n\t\t\tdecoded.history.now = now.toUTCString();\n\t\t\tsecondsAgo = (bytes[pos++] << 24) | (bytes[pos++] << 16) | (bytes[pos++] << 8) | bytes[pos++];\n\t\t\tdecoded.history[seqNr].timeStamp = new Date(now.getTime() - secondsAgo*1000).toUTCString();\n\t\t\ttype = bytes[pos++];\n\t\t\tdecodeFrame(type, decoded.history[seqNr]);\n\t\t\tseqNr++;\n\t\t}\n\t}\n\treturn decoded;\n}\n\nfunction decodeUplink(input) {\n\treturn {\n\t  data : Decoder(input.bytes, input.fPort),\n\t};\n}\n\nfunction normalizeUplink(input) {\n    var data = {};\n\n    if (input.data && input.data.temperature && input.data.temperature.value) {\n        data.air = { temperature: input.data.temperature.value };\n    }\n\n    if (input.data && input.data.battery) {\n        data.battery = input.data.battery;\n    }\n\n    return { data: data };\n}\n",
            "environment": "javascript",
            "storage": "",
            "version": "1.0"
          }
        },
        "_resources": {
          "properties": []
        }
      }
    ]
  }
}