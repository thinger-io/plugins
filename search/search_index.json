{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Making IoT simpler","text":"<p>Welcome to Thinger.io Marketplace</p>"},{"location":"announcements/","title":"Announcements","text":""},{"location":"announcements/vs-code-plugin-version-2460-1/","title":"VS Code Plugin Version 4.14.1-1","text":"<p>Today we are announcing that we have released a new VS Code version for Thinger.io with some improvements  . With this new version, you will be able to update the firmware via OTA  directly from the Cloud.</p> <p> </p> <p>As part of this version both PlatformioIO and Thinger.io Visual Studio Code extensions are installed on first boot, and the necessary credentials are configured automatically, so no other configuration from the users are needed.</p> <p>Checkout the documentation for the plugin as well as for the OTA programming.</p>"},{"location":"announcements/vs-code-plugin-version-2460-1/#highlights","title":"Highlights","text":"<ul> <li>Preinstallation of platformio-ide and thinger-io extension</li> <li>Default settings for Thinger.io extension configuration</li> </ul>"},{"location":"announcements/prometheus-plugin-version-2460-1/","title":"Prometheus Plugin Version 2.46.0-1","text":"<p>We are very glad to announce that Prometheus is now available in our Plugins Marketplace. Go ahead and install it to provide full suport alongside the Prometheus Exporter Plugin as well as the Prometheus developed Alertmanager Plugin.</p> <p> </p> <p>Checkout the doc for the this plugin.</p>"},{"location":"announcements/alertmanager-plugin-version-0260-1/","title":"Alertmanager Plugin Version 0.26.0-1","text":"<p>Following the release of the Prometheus Plugin we announce the availability of the Alertmanager in our Plugins Marketplace. Don't forget to install the Prometheus Plugin as well as the Prometheus Exporter Plugin.</p> <p> </p> <p>Checkout the doc for the this plugin.</p>"},{"location":"announcements/sftpgo-plugin-version-254-1/","title":"SFTPGo Plugin Version 2.5.4-1","text":"<p>Alongside with the support of one of our customers  we've integrated SFTPGo, a new Plugin to add capabilities to File Storages, adding support for SFTP, FTP and FTPS with individual user management. With this plugin you can leverage Thinger.io file storage backends for exchanging and storing files on the platform.</p> <p>The support for this plugin in Thinger.io starts from the server version 5.3.6.</p> <p> </p> <p>Checkout the doc for the this plugin.</p>"},{"location":"announcements/node-red-plugin-version-150-1/","title":"Node-RED Plugin Version 1.5.0-1","text":"<p>From Thinger.io we have released a new Node-RED Plugin version with some improvements and fixes.</p> <p>Between the highlights of this new version, we have added the possibility to filter by tags in the bucket read node, needed feature when using product buckets.</p> <p> </p> <p>Also available for configuration in the input message:</p> <p> </p> <p>It is now possible to add a project to the device and bucket create nodes, extending and replicating the capabilities available in the UI.</p> <p> </p> <p>Between the fixes, we have made some improvements into the storage read and write nodes.</p> <p>The full changelog is available here</p> <p>In regards of the underlying Node-RED, we have update it to the last version 3.1.0. More information in Node-REDs blog post.</p> <p>Checkout the doc for the this plugin.</p>"},{"location":"announcements/node-red-plugin-version-160-1/","title":"Node-RED Plugin Version 1.6.0-1","text":"<p>From Thinger.io we have released a new Node-RED Plugin version with some improvements and fixes, thanks to the support of our community.</p> <p>The main feature is the configuration of setting Timezone in the Bucket Read node.</p> <p> </p> <p>Also, the addition of the Project filter in the Asset Iterator node for devices and buckets.</p> <p> </p> <p>We welcome everyone to interact with us through our community at community.thinger.io as well as from this extensionss GitHub repository</p> <p>The full changelog is available here</p> <p>Checkout the doc for the this plugin.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thinger.io plugins are extensions that allow complementing Thinger.io Platform with additional features or creating integrations with third-party services, data analytics algorithms or custom software.</p> <p>Before developing a plugin, it may be useful to familiarize with the infrastructure built by Thinger.io to work with additional services under the Plugins System Infrastructure section.</p>"},{"location":"contributing/#repository-content","title":"Repository content","text":"<p>This repository contains all available integrations for Thinger.io Marketplace.</p> <p>The wiki documents the file structure of the plugins as well as how to development and how to contribute to this repo so all the community can benefit from everyone's participation.</p> <p>Check out the following sections:</p> <ul> <li>Plugin Structure</li> <li>Writing a Plugin</li> <li>Documentation</li> </ul>"},{"location":"contributing/#get-in-touch","title":"Get in touch","text":"<p>To ask a question, offer suggestions, request new features, or get help configuring or installing plugins, please reach us at Thinger.io community</p> <p>If you spot any bugs within the plugins integration, check the issues for a similar one and if none exist create a new one.</p>"},{"location":"contributing/plugin-system-infrastructure/","title":"Plugin System Infrastructure","text":"<p>Thinger.io is built to be able to integrate third-party services and expand the functionality of the Platform.</p>"},{"location":"contributing/documentation/","title":"Documentation","text":"<p>Thinger.io's technical documentation is available at docs.thinger.io, with a dedicated plugins marketplace portal at this URL (marketplace.thinger.io).</p> <p>To make it easier for the users to evaluate the plugins available and to help them configure it, every new plugin should include a dedicated page, with a description.</p> <p>Documentation source is handled through the same repository as the source files of the plugin and in the same subfolder, written in Markdown.</p>"},{"location":"contributing/structure/","title":"Plugin Structure","text":"<p>In this monorepo, each plugin has its own folder with the name of its id, which contains all neccesary files to publish new plugins to Thinger.io Platform.</p>"},{"location":"contributing/structure/#necessary-files","title":"Necessary files","text":"<p>Each plugins must contain at least the following files:</p> <ul> <li>Plugin file</li> <li>Readme</li> <li>Changelog</li> </ul> <p>In each one of the above links you'll find more information regarding the type, standard and content of each file.</p>"},{"location":"contributing/structure/#optional-files","title":"Optional files","text":"<p>The optional files are subject to the way in which the plugin is built, deployed and launched. Therefore, this sections contains just some examples that the plugins may include.</p> <p>Some of the optional files could be:</p> <ul> <li>Dockerfile</li> <li>Configuration files</li> </ul> <p>Of course, every plugin is different, so the optional files are not limited to the above types, and anything may be added as long as it it neccesary and is handled by either the build, deployment or execution of the plugin.</p>"},{"location":"contributing/structure/changelog-file/","title":"Changelog","text":"<p>Each plugin must have and individual <code>CHANGELOG.md</code> file in its plugin directory.</p> <p>This file will contain any important updates to the plugin version or dependencies, as well as any changes to the file structure, build, deployment or configuration files.</p>"},{"location":"contributing/structure/changelog-file/#versioning","title":"Versioning","text":"<p>As some plugins are not built by us, and we just take their docker image and generate the necessary plugin files and settings to integrate with Thinger.io, versions would be more understandable if they followed the original software versioning, which most of the times aligns with Semver<sup>1</sup>, and append the release number of our settings files, leaving plugins versions as follows:</p> <ul> <li>MAJOR.MINOR.PATCH-CONFIG (i.e.: jupyter/minimal:3.10.5-2)</li> </ul> <p>Meaning, we download version 3.10.5 of jupyter/minimal image and have applied two updates over our integration files.</p> <p>Our own developed plugins, would be versioned by semver standard[^sermver], so their integration will follow the same rules above described.</p> <p>For plugins that don't need to follow the original service, or are not based in a third-party service, it is enough with following the Semver<sup>1</sup> as <code>MAJOR.MINOR.PATH</code> naming.</p>"},{"location":"contributing/structure/changelog-file/#content","title":"Content","text":"<p>For the content of the plugin we propose two different approaches, depending if the plugin is based on another service or if it contains both the services/resources and the integration with Thinger.io. Both of this approaches are based on the Keep a Changelog<sup>2</sup> proposal, with minimal adjustments.</p>"},{"location":"contributing/structure/changelog-file/#short-changelog","title":"Short Changelog","text":"<p>For the plugins that integrate third-party services and the files included in its directory are keept at a minimum, a short Changelog is enough, containing the version, date and a list of changes to the version.</p> CHANGELOG.md<pre><code># Changelog\n\nAll notable changes to InfluxDB2 plugin will be documented here.\n\n### [1.0.1] - 2022-11-17\n\n- Example message\n\n### [1.0.0] - 2022-06-28\n\n- Initial InfluxDB2 plugin\n\n[1.0.0]: https://github.com/thinger-io/plugins/compare/influxdb2/1.0.0...influxdb2/1.0.1\n[1.0.0]: https://github.com/thinger-io/plugins/tag/influxdb2/1.0.0\n</code></pre> <p>An example of this type of Changelog is the Node-RED Plugin Changelog which is based in a different service developed in-house, found at node-red-contrib-thinger</p>"},{"location":"contributing/structure/changelog-file/#extensive-changelog","title":"Extensive Changelog","text":"<p>Plugins that include additional information or developments are required to document any changes, fixed or updates further. For this use case the base Changelog is the one from Keep a Changelog<sup>2</sup>, without the <code>Unreleased</code> section. Below an example:</p> CHANGELOG.md<pre><code># Changelog\nAll notable changes to this project will be documented in this file.\n\n## [1.1.0] - 2019-02-15\n\n### Added\n\n- Danish translation.\n- Changelog inconsistency section in Bad Practices\n\n### Changed\n\n- Fixed typos in Italian translation.\n\n## [1.0.0] - 2017-06-20\n\n### Added\n\n- New visual identity by [@tylerfortune8](https://github.com/tylerfortune8).\n- Version navigation.\n\n### Fixed\n\n- Fix Markdown links to tag comparison URL with footnote-style links.\n\n### Removed\n\n- Section about \"changelog\" vs \"CHANGELOG\".\n\n[1.1.0]: https://github.com/olivierlacan/keep-a-changelog/compare/1.0.0...1.1.0\n[1.0.0]: https://github.com/olivierlacan/keep-a-changelog/releases/tag/1.0.0\n</code></pre> <p>Of course, anyone is welcome to add their own GitHub alias and URL to their contributions.</p> <ol> <li> <p>https://semver.org/ \u21a9\u21a9</p> </li> <li> <p>https://keepachangelog.com/en/1.1.0/ \u21a9\u21a9</p> </li> </ol>"},{"location":"contributing/structure/configuration-files/","title":"Configuration Files","text":"<p>In order for a plugin to work, additional configuration may be neccesary, to describe for example, the user id to use in the environment, the base url or any other setting specific to the plugin.</p> <p>The way to add plugin specific configuration is to create a directory, with any name, inside the Plugin Structure, containing the files that are to be used by the plugin. Then in the Plugin File, declare the volume to mount and the path to mount it to. More information under the deployment description of the Plugin File.</p> <p>If after developing a Plugin the GUI it is not shown it may be due to additional configuration in the integrated service.</p> <p>Two good examples to review are:</p>"},{"location":"contributing/structure/configuration-files/#grafana-plugin-datasources","title":"Grafana Plugin Datasources","text":"<p>The Grafana Plugin includes the default datasources to connect to the InfluxDB2 instance used by the Thinger.io Platform.</p>"},{"location":"contributing/structure/configuration-files/#jupyter-minimal-plugin-configuration","title":"Jupyter Minimal Plugin Configuration","text":"<p>The Jupyter Minimal Plugin includes the necessary configuration of the server included in the Jupyter Docker Image in order for it to work with the Thinger.io Platform.</p>"},{"location":"contributing/structure/dockerfile/","title":"Dockerfile","text":"<p>With Dockerfiles, we can describe the way in which to build a Plugin, that will then be available on the platform.</p> <p>This Dockerfiles must be placed inside a directory called <code>task</code>. There a currently no limits in what this Dockerfiles should contain, nevertheless they should be as independent and minimal as possible.</p> <p>Also, the <code>task</code> directory must contain every file necessary to build the Docker image. Once built, the image will then be uploaded to Docker Hub by the CI system integrated in GitHub, so no further steps need to be taken by the developer apart from testing locally and in a development branch before merging into master.</p> <p>There are multiple examples within Thinger.io Plugins that are built this way, checkout out Node-RED Plugin and TTN Stack Plugin.</p>"},{"location":"contributing/structure/plugin-file/","title":"Plugin File","text":"<p>This is the main file for every plugin, as it contains all neccesary metadata for its deployment.</p> <p>The files name is <code>plugin.json</code> and follows the <code>package.json</code> standard for NPM packages<sup>1</sup> with additional elements neccesary to describe the build and deployment of the plugins within the Thinger.io Platform.</p>"},{"location":"contributing/structure/plugin-file/#required-content","title":"Required content","text":"<p>The most basic content that a <code>plugin.json</code> file must contain, its structure and description for each element is</p> plugin.json<pre><code>{\n  \"name\" : \"&lt;id of the plugin, same as its directory name (lowercase and with hyphens in place of spaces)\",\n  \"version\" : \"&lt;current production version of the plugin\",\n  \"description\" : \"&lt;short description of the plugin\",\n  \"author\" : \"&lt;name or github alias for the integrator of the plugin&gt;\",\n  \"license\" : \"MIT\",\n  \"repository\" : {\n    \"type\" : \"git\",\n    \"url\" : \"https://github.com/thinger.io/plugins.git\"\n  },\n  \"metadata\" : {\n    \"name\" : \"&lt;full name&gt;\",\n    \"description\" : \"&lt;description of the plugin&gt;\",\n    \"image\" : \"&lt;image url to display in Thinger.io Marketplace&gt;\",\n    \"icon\" : \"&lt;icon url to display in Thinger.io sidebar&gt;\"\n  }\n}\n</code></pre> <p>Of course, based on the deployment and configuration of the plugin there are other available elements that will define how Thinger.io will handle it.</p>"},{"location":"contributing/structure/plugin-file/#additional-configuration","title":"Additional configuration","text":""},{"location":"contributing/structure/plugin-file/#tokens","title":"Tokens","text":"<p>This element will define if any token needs to be created, its name and permissions. If the plugin is deployed in a Docker container, Thinger.io will pass the token to its environment as <code>THINGER_TOKEN_&lt;NAME_OF_TOKEN&gt;</code>.</p> <p>Below you can find and example, used by the Sigfox Plugin:</p> plugin.json<pre><code>{\n  \"tokens\" : {\n    \"sigfox_plugin\" : {\n      \"name\" : \"Access from Sigfox plugin to thinger.io account\",\n      \"allow\" : {\n        \"Device\" : {\n          \"*\" : [\"CreateDevice\", \"SetDeviceProperty\", \"ReadDeviceProperty\", \"UpdateDeviceCallback\", \"CallDeviceCallback\", \"ReadDeviceCallbackResponse\"]\n        },\n        \"Bucket\" : {\n          \"*\" : [\"CreateBucket\"]\n        },\n        \"Plugin\" : {\n          \"sigfox\" : \"*\"\n        }\n      }\n    },\n    \"sigfox_plugin_callback\" : {\n      \"name\" : \"Access from Sigfox network to plugin callback\",\n      \"allow\" : {\n        \"Plugin\" : {\n          \"sigfox\" : [\"CallPluginEndpoint\"]\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Therefore inside the Sigfox environemnt two tokens will exist, <code>THINGER_TOKEN_SIGFOX_PLUGIN</code> and <code>THINGER_TOKEN_SIGFOX_PLUGIN_CALLBACK</code>.</p>"},{"location":"contributing/structure/plugin-file/#deployment-description","title":"Deployment description","text":"<p>Defined by the element <code>task</code>, currently only for Docker deployments, this element describes how Thinger.io will launch and configure the environment. It contains details about the docker image to use, the environemt variables inside the container, the volumes attached, copy of configuration files...</p> <p>The best example in this case is the Grafana Plugin:</p> plugin.json<pre><code>{\n  \"task\" : {\n    \"env\" : {\n      \"GF_SERVER_DOMAIN\" : \"${THINGER_HOST}\",\n      \"GF_SERVER_ROOT_URL\": \"https://${THINGER_HOST}/users/${THINGER_USER}/plugins/${THINGER_PLUGIN}/\",\n      \"GF_SERVER_SERVE_FROM_SUB_PATH\" : \"true\",\n      \"GF_SERVER_ENABLE_GZIP\" : \"true\",\n      \"GF_SECURITY_ADMIN_USER\" : \"${THINGER_USER}\",\n      \"GF_SECURITY_COOKIE_SECURE\" : \"true\",\n      \"GF_SECURITY_COOKIE_SAMESITE\" : \"strict\",\n      \"GF_ANALYTICS_REPORTING_ENABLED\" : \"false\",\n      \"GF_SECURITY_ALLOW_EMBEDDING\" : \"true\",\n      \"GF_LOG_MODE\" : \"console\",\n      \"THINGER_INFLUXDB_TOKEN\": \"{{THINGER_INFLUXDB_TOKEN}}\"\n    },\n    \"type\" : \"docker\",\n    \"image\" : \"grafana/grafana:8.5.4\",\n    \"volumes\" : [\n      {\n        \"source\": \"data\",\n        \"target\": \"/var/lib/grafana\",\n        \"description\": \"Mount point for user data configuration\"\n      },\n      {\n        \"source\": \"datasources\",\n        \"target\": \"/etc/grafana/provisioning/datasources/\",\n        \"description\": \"Mount point for preconfigured datasources\"\n      }\n    ],\n    \"copy\": {\n      \"datasources\": \"datasources\"\n    }\n  }\n}\n</code></pre> <p>In this case we see different subelements:</p> <ul> <li><code>env</code>: environment variables passed to the Docker environment.</li> <li><code>type</code>: docker.</li> <li><code>image</code>: defines the docker image to create the container from. If the version is omitted, it will append the version from the plugin, which corresponds to the <code>version</code> element of the <code>plugin.json</code> file.</li> <li><code>volumes</code>: declares the data volumes that will attach to the container. In this case there are two, <code>data</code>, that is used to persist the path <code>/var/lib/grafana</code>, in case the container is restarted or updated; and <code>datasources</code>, used for preconfiguration files copied to the container.</li> <li><code>copy</code>: defines the directory to copy from the Plugin Structure, into the name volume defined in the <code>volumes</code> section.</li> </ul> <p>Additional to the plugin defined environment variables, there are Thinger.io defined, that can be used to construct additional variables as shown in the above example, which are:</p> <ul> <li>THINGER_HOST</li> <li>THINGER_USER</li> <li>THINGER_PLUGIN</li> <li>THINGER_PLUGIN_VERSION</li> <li>THINGER_HTTP_PORT</li> <li>THINGER_HTTP_SSL_PORT</li> <li>THINGER_INFLUXDB_TOKEN</li> </ul>"},{"location":"contributing/structure/plugin-file/#thingerio-resources","title":"Thinger.io resources","text":"<p>Besides tokens, any other resources may be declared in the file and the Thinger.io Platform will handle its creation. This can be useful to create for example proxies to different services or additional file storages that, if correctly configured, will then be used by the plugin.</p> <p>The following example, extracted from the InfluxDB2 Plugin, creates a Proxy resource against the existing InfluxDB container used as the backend of Thinger.io Platform.</p> plugin.json<pre><code>{\n  \"resources\" : {\n    \"proxies\" : [\n      {\n        \"proxy\" : \"influxdb2_plugin\",\n        \"enabled\" : true,\n        \"name\" : \"InfluxDB2 Plugin Access\",\n        \"description\" : \"InfluxDB2 Proxy created by plugin\",\n        \"config\" : {\n          \"protocol\" : \"tcp\",\n          \"source\": {\n            \"port\": 8087,\n            \"secure\": true\n          },\n          \"target\": {\n            \"type\": \"address\",\n            \"address\" : \"localhost\",\n            \"port\" : 8086,\n            \"secure\" : false\n          }\n        }\n\n      }\n    ]\n  }\n}\n</code></pre> <p>In this particular case, a proxy is created from the port 8087 of the Host machine to the port 8086 of the localhost, being able to access externally to the InfluxDB2 dashboard.</p> <p>Other resources are described under the sections Platform Features and Business Features of the official Thinger.io Platform documentation.</p> <p>For specific details on how to declare the resources and details checkout other plugins or reach us at Thinger.io community</p>"},{"location":"contributing/structure/plugin-file/#user-interface","title":"User interface","text":"<p>To be able to see either the web interface of a plugin or the developed interface, it is neccesary to define either the port and name of the container or the GUI file from which to execute.</p> <p>This first example, proxies from the Thinger.io frontend to the Node-RED Plugin:</p> plugin.json<pre><code>{\n  \"interface\" : {\n    \"main\" : {\n      \"proxy_to\" : {\n        \"plugin\" : \"node-red\",\n        \"port\" : 1880,\n        \"rewrite_base_path\": true\n      }\n    }\n  }\n}\n</code></pre> <p>The second example, opens the frontend from an in-house development based in Angular, in particular for the TTN-Stack Plugin:</p> plugin.json<pre><code>{\n  \"interface\" : {\n    \"main\" : {\n      \"file\" : \"gui/ttn-stack-settings.js\"\n    }\n  }\n}\n</code></pre> <ol> <li> <p>https://docs.npmjs.com/cli/v9/configuring-npm/package-json \u21a9</p> </li> </ol>"},{"location":"contributing/structure/readme-file/","title":"Readme","text":"<p>The <code>README.md</code> file servers three purposes:</p> <ul> <li>See the description while navigating GitHub plugins</li> <li>See the description inside the Thinger.io Marketplace</li> <li>See the description in the official Thinger.io Docs</li> </ul> <p>Therefore, and to enrich these locations, the file must be present and be as verbose as possible, including images and any necessary resource.</p>"},{"location":"contributing/writing/","title":"Writing a Plugin","text":"<p>In order to provide a highly extensive system we are working to make it easy for community developers to contribute through Open Source plugins. This section will provide deeply information about the infrastructure that is supporting plugins system and how to build, test and deploy custom ones.</p> <p>Keep in mind that any plugin installation is still limited by your Cloud Pricing Plan.</p> <p>First of, there are different use cases, depending if we want to integrate an existing service with Thinger.io, if we'd like to develop our own service with or without a frontend and plugins to create default resources for off-the-self hardware (Shelly or Sonnof devices, for example).</p> <p>Based on this requirement and in other of enumaration, you may go to the section that best suits your needs:</p> <ul> <li>Integrating services</li> <li>Developing custom plugins</li> <li>Off-the-shelf hardware integration</li> </ul> <p>Nevertheless, all of this use cases must follow the Plugin Structure, but each one of them will use different elements in its <code>plugin.json</code> file. Don't forget to familiarize with all the available options first.</p> <p>Once you have all the necessary files, and before uploading the plugin to the repository, it is useful to test the plugin in your own Thinger.io environment. The instructions on how to test it out are in the deploying local plugins section.</p>"},{"location":"contributing/writing/deploying-local/","title":"Deploying Local Plugins","text":"<p>Plugins can be developed and tested inside Thinger.io Platform, providing an environment before opening a Pull Request against this repository. The only step that Thinger.io does not integrate in itself is the CI system and upload to Docker Hub, so the Docker images should be created locally and uploaded to a users public Docker repository.</p> <p>To develop a Plugin, follow the steps:</p> <ol> <li>Create a File Storage with any name.</li> <li>Inside the newly created File Storage, place the neccesary files by following the Plugin Structure section.</li> <li>Automatically, Thinger.io Marketplace will fetch the <code>plugin.json</code> if it is correctly built.</li> <li>Once tested, upload all files to this repository alonside the documentation.</li> </ol>"},{"location":"contributing/writing/developing-custom-plugins/","title":"Developing Custom Plugins","text":"<p>A plugin may be self-contained, meaning that everything from the back-end, front-end and integration with Thinger.io is include in its own plugin directory.</p> <p>An example of this type of plugin would be the TTN-Stack Plugin, which is developed in Node.js for the back-end and Angular for the front-end.</p>"},{"location":"contributing/writing/developing-custom-plugins/#back-end","title":"Back-end","text":"<p>To develop the backend, any technology may be used as long as it is able to run under a Docker container.</p> <p>Under a directory called <code>task</code>, include the source code and any file necessary for the build and execution of the server, as well as the Dockerfile, with the CI system will use to generate the image for the plugin.</p> <p>Checkout this example.</p>"},{"location":"contributing/writing/developing-custom-plugins/#front-end","title":"Front-end","text":"<p>If the front-end is not integrated inside the container, where the back-end is located, a front-end may be developed with Angular and placed under a directory called <code>gui</code>.</p> <p>Checkout this example.</p>"},{"location":"contributing/writing/developing-custom-plugins/#thingerio-integration","title":"Thinger.io integration","text":"<p>The integration with Thinger.io Marketplace would be very similar or the same as any other plugin under the integrating services section, only in the case that the GUI is developed outside the container the user interface section must refer to the Angular <code>settings.js</code> file.</p>"},{"location":"contributing/writing/integrating-services/","title":"Integrating Services","text":"<p>Third-party service integration is one of the main objectives of the Thinger.io Marketplace, therefore the Plugin System is built around this use case.</p> <p>Most commonly, the service will be deployed in a Docker container and the Thinger.io Platform will reverse proxy its access to be able to see the front-end, if available.</p> <p>There may some cases in which the service does now allow its deployment behind a reverse proxy, for this causistica, Thinger.io implements proxies, that open a port on the Host machine pointing to the service.</p> <p>Ideally, the former way is the first approach that every plugin should follow, as it does not modify the hosts network infrastructure.</p> <p>In the Plugin Structure section is described the neccesary files to integrate a service. Specifically, check out deployment description and user interface sections under Plugin File for specifics in how to deploy a Docker service; and Dockerfile for details in how to add additional functionality or add-ons to Docker images.</p> <p>Examples of integration of services are the Grafana Plugin and Jupyter Minimal Plugin; and an example with extending features would be the Node-RED Plugin.</p>"},{"location":"contributing/writing/off-the-shelf-hardware/","title":"Off the Shelf Hardware Integration","text":"<p>In order to streamline integrations of off-the-shelf hardware, as it may be the case for different controllers of Shelly or Sonoff, for example; Plugins may be developed to just create resources like devices, dashboards, endpoints, dashboards and any other interesting resource that may be used with the hardware.</p>"},{"location":"how_it_works/","title":"How It Works","text":"<p>Thinger.io Marketplace is an ecosystem that supports the collaboration of hardware manufacturers and IoT solution developers. It leverages powerful Thinger.io Plugins to extend the capabilities of the IoT Platform, providing users with a wide range of possibilities.</p> <p> </p> <p>The core of the Thinger.io IoT Platform is intentionally lightweight and flexible, ensuring maximum adaptability and ease of configuration for IoT networks. Through the marketplace\u2019s diverse collection of plugins, users can enhance the platform with additional features, seamlessly integrate third-party internet services, implement advanced data analytics algorithms, and even create custom software tailored to their specific needs.</p> <p>This collaborative environment empowers users to customize their IoT servers on-demand, offering the flexibility to adapt and scale their projects as required. With Thinger.io Marketplace, the potential for innovation and creative solutions within the IoT space is boundless.</p>"},{"location":"how_it_works/#our-goal","title":"Our Goal","text":"<p>At Thinger.io Marketplace, our primary objective is to foster a win-win ecosystem for all stakeholders involved in the IoT industry. Our platform aims to deliver high-quality solutions while streamlining costs and reducing development timelines, creating a mutually beneficial environment for everyone.</p> <p> </p> <p>In summary, our goal at Thinger.io Marketplace is to create a collaborative and thriving ecosystem, bringing together hardware manufacturers, consultancies, the community, and end customers. Through this platform, we aim to provide a seamless experience for all participants, fostering innovation, and accelerating the adoption of IoT solutions worldwide.</p>"},{"location":"how_it_works/community/","title":"Community","text":"<p>We believe in the power of community-driven innovation. At Thinger.io Marketplace, developers and enthusiasts are encouraged and supported in contributing to our ecosystem. Create plugins and integrations for third-party devices, expanding the capabilities of the Thinger.io IoT Platform. By publishing your work on our platform, you not only gain recognition for your innovative contributions but also have the opportunity to generate revenue. Join us in shaping the future of IoT technology through collaborative efforts.</p> <p>Check out our community!</p> <p>To the community</p>"},{"location":"how_it_works/end_customers/","title":"End Customers","text":"<p>Searching for cutting-edge IoT solutions to meet your specific needs? Look no further than Thinger.io Marketplace. Our diverse range of high-quality products and services, sourced from top hardware manufacturers, consultancies, and community contributors, ensures you find the perfect-fit solution. Explore and select from a wide array of options, delivering reliable and efficient technology that will elevate your IoT experiences to new heights.</p> <p>Don't hesitate to contact us if you need more information:</p> <p>Contact Us</p>"},{"location":"how_it_works/hardware_manufacturers/","title":"Hardware Manufacturers","text":"<p>Are you a hardware manufacturer with groundbreaking devices waiting to be introduced to the world? Look no further! Thinger.io Marketplace offers you a global stage to showcase your innovative creations and connect with a diverse audience. By joining our marketplace, you can boost the visibility of your products, leading to increased sales and expanded market reach. Take your devices to new heights and watch your brand flourish in the thriving IoT landscape.</p> <p> </p> <p>We provide a platform to showcase and introduce their innovative devices to a global audience. By joining our marketplace, hardware manufacturers can increase the visibility of their products, leading to enhanced device sales and market reach.</p> <p>Benefits</p> <p>Reduce time-to-market &amp; developments costs</p> <p>Increase hardware product visibility &amp; sales</p> <p>Creates an ecosystem of compatible devices in which they must be</p> <p>In just four easy steps a simple hardware can be integrated in the platform for thousand of users:</p> <ol> <li>They integrate their IoT products using our uniform framework and no-code tools. Simple and reliable.</li> <li>They custom the dashboards Look &amp; feel and configuration forms with their branding.</li> <li>The integration is encapsulated in a new device plugin that allows to deploy devices within seconds.</li> <li>The new plugin is released at Thinger.io Marketplace.</li> </ol> <p>Don't hesitate to contact us if you need more information:</p> <p>Contact Us</p>"},{"location":"how_it_works/iot_consultants/","title":"IoT Consultants","text":"<p>Thinger.io Marketplace presents an unparalleled opportunity for consultancies to excel in IoT integration. With our support, you can efficiently develop last-mile integrations and seamlessly deploy devices for your clients. Connecting with potential customers becomes a breeze, allowing you to identify the perfect-fit solutions for their unique needs. With enhanced customer satisfaction and project success, you\u2019ll establish yourself as a go-to consultancy in the IoT realm.</p> <p> </p> <p>Thinger.io Marketplace offers a unique opportunity for consultancies to develop last-mile integrations and facilitate seamless device deployment for their clients. By leveraging our platform, consultancies can efficiently connect with potential customers and identify the best-suited devices for their specific solutions, resulting in improved customer satisfaction and project success.</p> <p>Benefits</p> <p>Fast and simpler development processes</p> <p>Reduce long-term technologic debt</p> <p>Win-win relationship: They find customers growing our SAAS sales</p> <p>Incorporating Thinger.io Marketplace into your consultancy toolkit offers a multitude of benefits, which include:</p> <ol> <li>Using the marketplace, consultancies find the best hardware for their projects.</li> <li>The plugin provides simple and fast devices configuration.</li> <li>Platform no-code tools allows them to custom the dataflow to the last-mile requirements.</li> <li>The new solution is ready to be deployed within a fraction of the cost and TTM.</li> </ol> <p>Don't hesitate to contact us if you need more information:</p> <p>Contact Us</p>"},{"location":"plugins/","title":"Plugins","text":"<p>Plugins are extensions that allow complementing Thinger.io Platform with additional features or creating integrations with third-party internet services, data analytics algorithms or custom software.</p> <p>The core of Thinger.io IoT Platform is designed to be lean and lightweight, to maximize flexibility and minimize learning and common configuration of IoT networks.  Plugins offer custom functions that can be deployed on-demand,  allowing each user to complement their IoT server as its specific needs.</p> <p>For instructions and information about installing, upgrading, troubleshooting, and managing Thinger.io plugins, see Managing Plugins section. For learning how to use any existent plugin, just find on the left a list of each one.</p> <p>Note</p> <p>Plugins are only available for premium Thinger.io servers. Check out the pricing page to create your own instance within minutes.</p> <p>To the pricing</p> <p>Tip</p> <p>Thinger.io plugins source code is now available in our Github repository,so if you want to contribute do not hesitate on forking to project and send your pull-requests. Link is in the top right corner of the page.</p>"},{"location":"plugins/#custom-plugins-development","title":"Custom Plugins Development","text":"<p>In order to provide a highly extensive system we are working to make it easy for community developers to contribute through Open Source plugins. Therefore, we have created a dedicated repository and wiki that provides deeply information about the infrastructure that is supporting plugins system and how to build, test and deploy custom ones.</p> <p>Go to the GitHub repository Contributing page</p>"},{"location":"plugins/managing/","title":"Managing Plugins","text":"<p>The Plugins Marketplace can be accessed by clicking the \"Plugins\" tab in the main menu.</p> <p> </p> <p>This interface displays the existing plugins that can be installed to extend the Thinger.io IoT Platform. The collection of plugins is continuously growing, offering various categories for easy filtering and management.</p>"},{"location":"plugins/managing/#install-and-deploy-an-existent-plugin","title":"Install and Deploy an Existent Plugin","text":"<p>Each plugin has a detailed description page that provides useful information about its features and usage. Additionally, users can access the plugin's Logs, Shell, and even Share it publicly.</p> <p> </p> <p>Users can easily manage plugins through the \"Plugin Management\" section. From here, they have the flexibility to perform various actions, such as installing, starting, stopping, killing, restarting, pausing, resuming, or removing a plugin.</p> <p> </p> <p>This graphical interface enables the following operations:</p> <ul> <li>Install: Installs the plugin, granting access to its services and features while adding a new tab in the main menu.</li> <li>Start: Deploys the execution of the plugin process. Press this button after installation or after stopping the process to restart the execution.</li> <li>Stop: Ends the execution of the plugin process gracefully.</li> <li>Kill: Forcefully terminates the plugin process.</li> <li>Restart: Performs a Stop + Start cycle for the plugin process.</li> <li>Pause: Halts the execution of the plugin while preserving all runtime variables.</li> <li>Resume: Resumes the plugin's execution after being paused.</li> <li>Remove: Uninstalls the plugin from the platform.</li> </ul>"},{"location":"plugins/managing/#analyzing-the-logs","title":"Analyzing the Logs","text":"<p>Accessing and monitoring your plugin logs at Thinger.io is a breeze. Follow these simple steps to gain valuable insights into your plugin's activities:</p> <ol> <li> <p>Select Your Plugin: Once you are logged into your Thinger.io account, navigate to the Plugins section and locate the plugin you wish to analyze. Click on the plugin's name or icon to access its detailed view.</p> </li> <li> <p>Click on the Logs Tab: Within the plugin's detailed view, you'll find a tab labeled Logs. Click on this tab to access the logs section.</p> </li> <li> <p>Connect to Logs: Upon entering the Logs tab, you'll notice a Connect button. Simply click this button to establish a connection to your plugin's logs.</p> </li> <li> <p>Monitor in Real-time: With the connection established, you now have real-time access to your plugin's logs. You'll be able to see a continuous stream of activities, events, and data generated by the plugin as it interacts with devices and the IoT ecosystem.</p> </li> <li> <p>Analyze and Troubleshoot: As the logs populate, carefully analyze the information presented. Look for any potential errors or anomalies that may require attention. The logs will offer valuable clues to the plugin's performance and reveal any issues that need to be addressed promptly.</p> </li> </ol> <p>By following these steps, you can effortlessly access and leverage the power of your plugin's logs.</p>"},{"location":"plugins/managing/#accessing-the-shell","title":"Accessing the Shell","text":"<p>The Shell feature, gives you full control over your plugin's configuration and allowes you to add packages or extensions effortlessly. With the Shell, you can execute instructions and commands directly, streamlining the process of customizing and fine-tuning your IoT solutions.</p> <p>To access the Shell and unleash its potential, follow these simple steps:</p> <ol> <li> <p>Locate Your Plugin: After logging into your Thinger.io account, navigate to the Plugins section and find the specific plugin you wish to configure or extend. Click on the plugin's name or icon to access its detailed view.</p> </li> <li> <p>Go to the Shell Tab: Within the plugin's detailed view, look for the Shell tab. Click on this tab to access the Shell feature.</p> </li> <li> <p>Connect to the Shell: Once you are in the Shell tab, you'll find a Connect button. Click this button to establish a connection to the plugin's Shell.</p> </li> <li> <p>Execute Instructions: With the connection established, you now have direct access to the plugin's Shell. Here, you can execute instructions, change configurations, and add packages or extensions with ease. Simply input the desired commands and watch the changes take effect.</p> </li> </ol> <p> </p> <p>The Shell feature grants you complete control over your plugin, allowing you to make real-time adjustments and tailor it to your specific needs. Whether you're tweaking configurations or adding new functionality, the Shell ensures a seamless and efficient experience.</p> <p>Rest assured that our Shell feature is designed with security in mind. We implement robust safeguards to prevent unauthorized access and ensure the integrity of your IoT ecosystem.</p>"},{"location":"plugins/managing/#public-access","title":"Public access","text":"<p>Thinger.io offers a convenient way to grant public access to your plugins, allowing a broader audience to benefit from your innovative solutions. However, it's essential to ensure the security of your plugin and data. To enable public access safely, follow these steps:</p> <ol> <li> <p>Access the Settings Tab: After logging into your Thinger.io account and selecting the plugin you want to make public, navigate to the plugin's detailed view. Look for the Settings tab and click on it to access the configuration options.</p> </li> <li> <p>Enable Public Access: Within the Settings tab, you'll find an option to enable public access. Toggle this option to provide access to your plugin to a wider audience.</p> </li> <li> <p>Verify Plugin Authentication: Before proceeding, it is crucial to ensure that your plugin is capable of handling authentication independently. Public access means that anyone can interact with your plugin, so it must have robust authentication mechanisms in place to safeguard data and maintain control over who can access the plugin's functionalities.</p> </li> <li> <p>Secure Your Plugin: Review your plugin's authentication process thoroughly and make any necessary adjustments to guarantee that unauthorized users cannot gain access. A robust authentication mechanism ensures that only legitimate users can utilize the plugin's features.</p> </li> </ol> <p> </p> <p>By following these steps, you can safely enable public access to your plugin and expand its reach to a broader audience. Public access opens up new opportunities for collaboration, feedback, and exposure, but ensuring the plugin's security and authentication measures is paramount. At Thinger.io Marketplace, we prioritize data protection and user privacy, making it easier for you to share your IoT solutions while maintaining control and security.</p>"},{"location":"plugins/alertmanager/","title":"Alertmanager","text":"<p>The Alertmanager handles alerts sent by clients applications such as Prometheus server. More information in their official documentation.</p>"},{"location":"plugins/alertmanager/#get-started","title":"Get Started","text":"<p>This plugins requires the existence of the Prometheus plugin, as it will create a new file storage called 'Prometheus Settings'. This file storage contains a template of the configuration in order to scrape the Prometheus Exporter Plugin endpoint. The installation of the Alertmanager plugin will add the <code>alertmanager.yml</code> configuration file as well as an example alert rule for Prometheus.</p> <p>In order for the connection to take place, edit the <code>prometheus.yml</code> file by introducing your details and selecting your desired configuration.</p> <p> </p> <p> </p>"},{"location":"plugins/alertmanager/#official-documentation","title":"Official Documentation","text":"<p>The Prometheus documentation offers extensive information on how to configure the alertmanger in case you require further details on what is provided by default.</p> <p>You can find how to configure Alermanager at this link and how to create alerting rules here.</p> <p>More details regarding the configuration of Prometheus at this link.</p> <p>Note</p> <p>Any configuration change in <code>prometheus.yml</code> or <code>rules.yml</code> requires a restart of the Prometheus plugin, and any change to <code>alertmanager.yml</code> requires a restart of the Alertmanager plugin.</p>"},{"location":"plugins/alertmanager/#license","title":"License","text":"<p>Alertmanager, as well as Prometheus are distributed under the Apache 2.0 License.</p>"},{"location":"plugins/alertmanager/changelog/","title":"Changelog","text":""},{"location":"plugins/alertmanager/changelog/#0260-1---2023-08-30","title":"0.26.0-1 - 2023-08-30","text":""},{"location":"plugins/alertmanager/changelog/#added","title":"Added","text":"<ul> <li>Create and upload Alertmanager plugin</li> </ul>"},{"location":"plugins/docker-registry/","title":"Docker Registry","text":"<p>Thinger.io plugin for running a Docker Registry in order to be able to upload and persist images of ML Models.</p> <p>More details in what this plugins includes can be found here</p>"},{"location":"plugins/docker-registry/changelog/","title":"Changelog","text":""},{"location":"plugins/docker-registry/changelog/#281-1---2023-03-23","title":"2.8.1-1 - 2023-03-23","text":""},{"location":"plugins/docker-registry/changelog/#added","title":"Added","text":"<ul> <li>First publication of plugin</li> </ul>"},{"location":"plugins/grafana/","title":"Grafana","text":"<p>Grafana is a powerful and versatile open-source platform designed to streamline the monitoring and observability of your metrics, regardless of their storage location. With Grafana, you can effortlessly query, visualize, set up alerts, and gain deep insights into your data, fostering a data-driven culture within your team.</p> <p> </p>"},{"location":"plugins/grafana/#key-features","title":"Key Features","text":""},{"location":"plugins/grafana/#1-visualize-your-metrics-with-ease","title":"1. Visualize Your Metrics with Ease","text":"<p>Grafana offers a blazing-fast and flexible client-side graphing capability with a myriad of customization options. The platform also supports a wide range of panel plugins, providing you with numerous ways to visualize metrics and logs exactly as you need them.</p>"},{"location":"plugins/grafana/#2-dynamic-and-reusable-dashboards","title":"2. Dynamic and Reusable Dashboards","text":"<p>Create dynamic and reusable dashboards using template variables, which appear as convenient dropdowns at the top of the dashboard. This allows you to easily manipulate and interact with your data, enhancing your dashboard's usability and adaptability.</p>"},{"location":"plugins/grafana/#3-explore-your-data-effortlessly","title":"3. Explore Your Data Effortlessly","text":"<p>Grafana empowers you to explore your data through ad-hoc queries and dynamic drilldowns. Compare different time ranges, queries, and data sources side by side, gaining valuable insights and trends from your data with ease.</p>"},{"location":"plugins/grafana/#4-seamless-transition-from-metrics-to-logs","title":"4. Seamless Transition from Metrics to Logs","text":"<p>Experience the seamless magic of switching between metrics and logs, with preserved label filters. Whether you need to search through all your logs or stream them live, Grafana has you covered, providing a unified monitoring experience.</p>"},{"location":"plugins/grafana/#5-powerful-alerting-mechanism","title":"5. Powerful Alerting Mechanism","text":"<p>Stay on top of your most critical metrics by visually defining alert rules. Grafana continuously evaluates these rules and ensures timely notifications to systems like Slack, PagerDuty, VictorOps, and OpsGenie.</p>"},{"location":"plugins/grafana/#6-mix-and-match-data-sources","title":"6. Mix and Match Data Sources","text":"<p>With Grafana, you can effortlessly mix different data sources within the same graph. This includes support for custom data sources, allowing you to tailor your monitoring setup according to your specific needs.</p>"},{"location":"plugins/grafana/#about-thingerio-and-grafana-integration","title":"About thinger.io and Grafana Integration","text":"<p>The integration of thinger.io with Grafana introduces an immensely valuable toolset for thinger.io users, enabling them to elevate their dashboards to a professional level, conduct intricate analytics in a scalable manner, and embark on collaborative visualization projects with fellow developers on their team. This seamless integration leverages the strengths of each component to create a powerful infrastructure, where thinger.io serves as a centralized hub for device administration and management.</p> <p>Here's how the integration works: First, data from devices is efficiently stored using a time series data store. thinger.io acts as a facilitator, managing and organizing this data behind the scenes. Then, Grafana takes center stage, extracting the time series data and transforming it into visually compelling representations. The result is a highly effective and user-friendly monitoring and observability solution.</p> <p>With this integration, users gain the ability to harness the full potential of both thinger.io and Grafana, unlocking new possibilities for data exploration, analysis, and visualization. Whether you need to fine-tune your IoT projects or collaborate with your team to drive data-driven decisions, this integration empowers you to do so with unparalleled efficiency and ease.</p> <p>Begin your journey with the thinger.io and Grafana integration today and experience the true power of data-driven insights and control. Empower your projects, elevate your dashboards, and unleash the full potential of your IoT infrastructure.</p> <p>Unsure if Grafana is for you? Watch Grafana in action on play.grafana.org!</p> <p>Starting with Grafana Plugin</p>"},{"location":"plugins/grafana/#official-documentation","title":"Official Documentation","text":"<p>The Grafana documentation is available at grafana.com/docs.</p>"},{"location":"plugins/grafana/#license","title":"License","text":"<p>Grafana is distributed under the Apache 2.0 License.</p>"},{"location":"plugins/grafana/changelog/","title":"Changelog","text":""},{"location":"plugins/grafana/changelog/#9311-1---2023-04-12","title":"9.3.11-1 - 2023-04-12","text":"<ul> <li>Bumped Grafana version to 9.3.11</li> </ul>"},{"location":"plugins/grafana/changelog/#854-1---2022-06-21","title":"8.5.4-1 - 2022-06-21","text":"<ul> <li>Bumped Grafana version to 8.5.4</li> <li>Added configuration for InfluxDB2-Flux backend</li> <li>Added default configuration for InfluxDB2-InfluxQL backend</li> </ul>"},{"location":"plugins/grafana/changelog/#834---2022-05-17","title":"8.3.4 - 2022-05-17","text":"<ul> <li>Bumped Grafana version to 8.3.4</li> </ul>"},{"location":"plugins/grafana/changelog/#806---2021-07-15","title":"8.0.6 - 2021-07-15","text":"<ul> <li>Updated Grafana version to 8.0.6.</li> <li>Fixed 404 not found problems with old Grafana install</li> </ul>"},{"location":"plugins/grafana/changelog/#706---2020-07-13","title":"7.0.6 - 2020-07-13","text":"<ul> <li>Initial Grafana plugin</li> </ul>"},{"location":"plugins/grafana/get_started/","title":"Getting Started with Grafana Plugin","text":"<p>After completing the standard plugin deployment process (as explained here), the Grafana plugin requires a few additional steps to work seamlessly with thinger.io devices' data. In the following sections, we'll guide you through the login process and how to configure the plugin effectively. First Login</p>"},{"location":"plugins/grafana/get_started/#first-login","title":"First Login","text":"<p>Upon installing the plugin, perform the initial login using your thinger.io account username and the password <code>admin</code>. After the first login, the system will prompt you to change the password to a custom one. Once done, you'll gain access to the Grafana workspace, offering a variety of options.</p> <p> </p>"},{"location":"plugins/grafana/get_started/#adding-a-datasource","title":"Adding a Datasource","text":"<p>The connection between Thinger.io data and the Grafana plugin is established by adding the buckets database as a <code>new data source</code> for Grafana. By default, the configuration for the database is set up with names InfluxDB2-Flux and InfluxDB2-InfluxQL, requiring no further action.</p> <p>Note</p> <p>For better performance, it is recommended to use the InfluxQL backend unless you require specific features available only with Flux.</p> <p> </p> <p>However, if needed, you can configure additional data sources. For more information, check this link.</p>"},{"location":"plugins/grafana/working_with_grafana/","title":"Working with Grafana","text":""},{"location":"plugins/grafana/working_with_grafana/#creating-a-new-dashboard","title":"Creating a New Dashboard","text":"<p>Once the data source is set up, the most common way to work with Grafana is by creating a new dashboard for data representation. Click on the \"+\" button in the Grafana main menu and select \"New Dashboard\". This opens an empty dashboard ready to be configured with custom layout and representation panels. Click on \"+Add new panel\" to open the panel configuration context, organized in two sections:</p> <ul> <li>Panel Configuration: Choose the type of graph to be used, such as time series charts, and explore various options for legends, axes, and more.</li> </ul> <p> </p> <ul> <li>Data Configuration in InfluxQL: Select the data source (InfluxDB2-InfluxQL in our example), a data bucket profile from Thinger.io, and specific variables for the panel.</li> </ul> <p> </p> <ul> <li>Data Configuration in Flux: Select the data source (InfluxDB2-Flux in our example) and write the desired data using Flux syntax</li> </ul> <p> </p> <ul> <li> <p>Transform data: Filter or aggregate device data using different tools before displaying it in the panel.</p> </li> <li> <p>Automatic Alerts: Configure the graph to generate real-time alerts based on evaluated variables.</p> </li> </ul>"},{"location":"plugins/grafana/working_with_grafana/#adding-new-widget-types","title":"Adding New Widget Types","text":"<p>Grafana is highly flexible, allowing users to add new panels and retrieve them from different repositories. These panels are developed by the Grafana team and community contributors, enabling rapid growth. To add new elements in the Thinger.io Grafana Plugin, use the command console of the local Docker container where Grafana is running. Execute the appropriate CLI installation command obtained from the official Grafana plugin repository.</p>"},{"location":"plugins/grafana/working_with_grafana/#share-grafana-projects-publicly","title":"Share Grafana Projects Publicly","text":"<p>Grafana can be configured to create collaborative working groups for sharing resources with read-only or editing privileges. This feature is valuable for creating visualization interfaces for customers. To implement this:</p> <ol> <li> <p>Go to the \"Permissions\" section of the dashboard you want to share and click the blue \"Add permission\" button.</p> </li> <li> <p>Select the user or team with whom you want to share the dashboard.</p> </li> <li> <p>Choose the desired privileges to grant.</p> </li> </ol> <p> </p> <p>However, when Grafana is running as a Thinger.io plugin, it is neccesary to give public access to the plugin as explained in the sercion \"Giving Public Access\" at the managing plugins page</p>"},{"location":"plugins/http-device/","title":"HTTP Devices","text":"<p>This plugin is specially useful for fleets of generic devices that can make HTTP requests.</p> <p>In a single HTTP request done by the device, this plugin can auto-provision the device and the data bucket if it does not exist. Moreover, it allows processing request/response payloads to process the information before it is stored in the data bucket, or before it is received by the device.</p>"},{"location":"plugins/http-device/#plugin-features","title":"Plugin features","text":"<ul> <li>Support for multiple device types or profiles</li> <li>Automatic device and bucket provisioning for new devices.</li> <li>Configurable default device timeout.</li> <li>Configurable device and bucket prefixes.</li> <li>Configurable device and bucket asset type and group.</li> <li>Support por defining custom request/response data processing on NodeJS.</li> <li>Payload Processing workbench.</li> </ul>"},{"location":"plugins/http-device/changelog/","title":"Changelog","text":""},{"location":"plugins/http-device/changelog/#102---2023-02-21","title":"1.0.2 - 2023-02-21","text":""},{"location":"plugins/http-device/changelog/#fixed","title":"Fixed","text":"<ul> <li>Ensure provided device type is available instead of using default settings</li> </ul>"},{"location":"plugins/http-device/changelog/#101---2023-02-20","title":"1.0.1 - 2023-02-20","text":""},{"location":"plugins/http-device/changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Make sure Thinger server is running before starting service</li> </ul>"},{"location":"plugins/influxdb2/","title":"InfluxDB2","text":"<p>InfluxDB is an open source time series platform. This includes APIs for storing and querying data, processing it in the background for ETL or monitoring and alerting purposes, user dashboards, and visualizing and exploring the data and more.</p> <p>InfluxDB is the default database backend for Thinger.io. This plugin allows direct access to the underlying installation and the user buckets for custom queries, dashboards, or alerts.</p> <p> </p>"},{"location":"plugins/influxdb2/#requirements","title":"Requirements","text":"<ul> <li>This plugin requires an instance with support for creating Proxies. Check your host admin in case of doubt.</li> <li>Proxies can be only initialized by admins. If a regular tenant (developer role) requires this plugin, please, ensure the admin also has this plugin installed to enable the required proxy.</li> </ul>"},{"location":"plugins/influxdb2/#resources-initialization","title":"Resources initialization","text":"<p>This plugin initializes the following resources</p> <ul> <li>TCP Proxy from 8087 (secure) to localhost at 8086.</li> </ul>"},{"location":"plugins/influxdb2/#get-started","title":"Get Started","text":"<p>After the plugin is installed, click on the InfluxDB2 plugin and access the interface with you regular Thinger.io username and password.</p> <p>Note: If the username and password does not work, please, change your Thinger.io password account.</p>"},{"location":"plugins/influxdb2/#license","title":"License","text":"<p>InfluxDB is distributed under the MIT License.</p>"},{"location":"plugins/influxdb2/changelog/","title":"Changelog","text":""},{"location":"plugins/influxdb2/changelog/#100---2022-06-28","title":"1.0.0 - 2022-06-28","text":"<ul> <li>Initial InfluxDB2 plugin</li> </ul>"},{"location":"plugins/jupyter-minimal/","title":"Jupyter Minimal","text":"<p>Thinger.io plugin for running Jupyter Minimal version on the Cloud, integrating with Thinger.io file storages.</p>"},{"location":"plugins/jupyter-minimal/#features","title":"Features","text":"<ul> <li>Have your Notebook where your data is, providing a unified management and data access</li> <li>Delegate the execution of the code and algorithms to a cloud environment</li> <li>Develop in a stable environment</li> </ul>"},{"location":"plugins/jupyter-minimal/#technical-features","title":"Technical Features","text":"<p>This version integrates the following technology:</p> <ul> <li>Python3 Runtime</li> <li>git</li> <li>TeX Live for document conversion.</li> </ul> <p>More details in what this plugins includes can be found here</p>"},{"location":"plugins/jupyter-minimal/#screenshots","title":"Screenshots","text":""},{"location":"plugins/jupyter-minimal/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"plugins/jupyter-minimal/changelog/#31010-1---2023-03-23","title":"3.10.10-1 - 2023-03-23","text":""},{"location":"plugins/jupyter-minimal/changelog/#added","title":"Added","text":"<ul> <li>Updated mount points to separate config and user data</li> </ul>"},{"location":"plugins/jupyter-minimal/changelog/#changed","title":"Changed","text":"<ul> <li>Bumped to image 3.10.10</li> </ul>"},{"location":"plugins/jupyter-minimal/changelog/#3109-2---2023-03-23","title":"3.10.9-2 - 2023-03-23","text":""},{"location":"plugins/jupyter-minimal/changelog/#fix","title":"Fix","text":"<ul> <li>Name was set to description and viceversa</li> </ul>"},{"location":"plugins/jupyter-minimal/changelog/#3109-1---2023-03-23","title":"3.10.9-1 - 2023-03-23","text":""},{"location":"plugins/jupyter-minimal/changelog/#added_1","title":"Added","text":"<ul> <li>First publication of plugin</li> </ul>"},{"location":"plugins/jupyter-r/","title":"Jupyter R","text":"<p>Thinger.io plugin for running Jupyter R version on the Cloud, integrating with Thinger.io file storages.</p>"},{"location":"plugins/jupyter-r/#features","title":"Features","text":"<ul> <li>Have your Notebook where your data is, providing a unified management and data access</li> <li>Delegate the execution of the code and algorithms to a cloud environment</li> <li>Develop in a stable environment</li> </ul>"},{"location":"plugins/jupyter-r/#technical-features","title":"Technical Features","text":"<p>This version integrates the following technology:</p> <ul> <li>R interpreter</li> <li>Python3 Runtime</li> <li>git</li> <li>TeX Live for document conversion.</li> </ul> <p>More details in what this plugins includes can be found here</p>"},{"location":"plugins/jupyter-r/#screenshots","title":"Screenshots","text":""},{"location":"plugins/jupyter-r/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"plugins/jupyter-r/changelog/#423-3---2023-03-29","title":"4.2.3-3 - 2023-03-29","text":""},{"location":"plugins/jupyter-r/changelog/#added","title":"Added","text":"<ul> <li>Updated mount points to separate config and user data</li> </ul>"},{"location":"plugins/jupyter-r/changelog/#423-2---2023-03-23","title":"4.2.3-2 - 2023-03-23","text":""},{"location":"plugins/jupyter-r/changelog/#changed","title":"Changed","text":"<ul> <li>Changed description in plugin.json</li> </ul>"},{"location":"plugins/jupyter-r/changelog/#423-1---2023-03-23","title":"4.2.3-1 - 2023-03-23","text":""},{"location":"plugins/jupyter-r/changelog/#added_1","title":"Added","text":"<ul> <li>First publication of plugin</li> </ul>"},{"location":"plugins/jupyter-tensorflow/","title":"Jupyter TensorFlow","text":"<p>Thinger.io plugin for running Jupyter TensorFlow version on the Cloud, integrating with Thinger.io file storages.</p>"},{"location":"plugins/jupyter-tensorflow/#features","title":"Features","text":"<ul> <li>Have your Notebook where your data is, providing a unified management and data access</li> <li>Delegate the execution of the code and algorithms to a cloud environment</li> <li>Develop in a stable environment</li> </ul>"},{"location":"plugins/jupyter-tensorflow/#technical-features","title":"Technical Features","text":"<p>This version integrates the following technology:</p> <ul> <li>TensorFlow machine learning library</li> <li>Popular packages from the scientific Python ecosystem</li> <li>Python3 Runtime</li> <li>git</li> <li>TeX Live for document conversion.</li> </ul> <p>More details in what this plugins includes can be found here</p>"},{"location":"plugins/jupyter-tensorflow/#screenshots","title":"Screenshots","text":""},{"location":"plugins/jupyter-tensorflow/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"plugins/jupyter-tensorflow/changelog/#2110-2---2023-03-23","title":"2.11.0-2 - 2023-03-23","text":""},{"location":"plugins/jupyter-tensorflow/changelog/#changed","title":"Changed","text":"<ul> <li>Improved description in plugin.json</li> </ul>"},{"location":"plugins/jupyter-tensorflow/changelog/#2110-1---2023-03-23","title":"2.11.0-1 - 2023-03-23","text":""},{"location":"plugins/jupyter-tensorflow/changelog/#added","title":"Added","text":"<ul> <li>First publication of plugin</li> </ul>"},{"location":"plugins/node-red/","title":"Node-RED","text":"<p>Node-RED is an Open Source project created by IBM to provide the Rule Engines market of a simple but powerful framework with an easy to use graphical programing interface, and a huge users community that has made more than 2.000 contributions.</p> <p>This technology begins especially useful for IoT projects, to process and analyze data or create rules to automate behaviors in response to events produced by the IoT devices measures. It can also be used as an MQTT broker or to show data in customizable dashboards. However, its greatest potential is obtained when used in combination with an IoT platform like Thinger.io, leaving one in charge of data acquisition, storage, and device management and the other one for processing, automation, etc.</p> <p> </p>"},{"location":"plugins/node-red/#thingerio-and-node-red-integration","title":"Thinger.io and Node-RED integration","text":"<p>We have made a great effort to simplify the integration between Thinger.io and Node-RED, which is materialized in the following elements: </p> <ul> <li> <p>A contribution to Node-RED repositories, called \"node-red-contrib-thinger\" that contains some nodes that has been specifically created to simplify the integration of Node-RED flows with Thinger.io features, allowing to interact with the IoT platform in the next ways:</p> <ul> <li>Iterate over the assets from the Thinger.io Platform (asset iterator node).</li> <li>Create buckets when an event occurs (bucket create node).</li> <li>Read from data buckets (bucket read node).</li> <li>Writing to data buckets (bucket write node).</li> <li>Calling devices callbacks with autoprovisioning (device callback node).</li> <li>Creating any type of devices (device create node).</li> <li>Reading a device resource when an event occurs (device read node).</li> <li>Subscribing to device resources at a given interval (device stream node).</li> <li>Sending data to a connected device (device write node).</li> <li>Calling endpoints (endpoint call node).</li> <li>Reading properties of devices, types or groups (property read node).</li> <li>Writing and modifying properties of devices, types or groups (property write node).</li> <li>Detecting different events of devices, buckets, endpoints and others (server events node).</li> <li>Reading file contents of file storages (read storage node).</li> <li>Writing new files or appending o existing files in file storages (write storage node).</li> </ul> </li> <li> <p>A Node-RED Plugin that allows deploying Node-RED server into the same host as Thinger.io IoT platform instance, running 24x7 without any kind of limitation. This way the problem of hosting the node-RED on another machine disappears</p> </li> </ul>"},{"location":"plugins/node-red/#introduction-to-node-red-concepts","title":"Introduction to Node-RED Concepts","text":"<p>Node-RED is a development tool with two basic components: a \"flow editor\" that consists of a graphical programming tool that can be launched over any web-browser and a backend with the rule engine server that is able to execute the flows. This system is really easy to learn and to use, however, there are some concepts that you should know before starting to work with it:</p>"},{"location":"plugins/node-red/#nodes","title":"Nodes","text":"<p>The \"Nodes\" are the basic building blocks for creating flows. Each node contains its own configuration form and specific behavior, that can be accessed by double-clicking the block once it has been introduced in the web editor canvas. There are a few basic types of nodes:</p>"},{"location":"plugins/node-red/#inject-nodes","title":"Inject Nodes","text":"<p>This node allows to automatically start a flow when an event is triggered, at regular intervals defined in the properties form or manually over the web editor. The message sent by these nodes has the payload and topic properties set. </p> <p>Function, Change, Switch Nodes</p> <p></p> <p>Node-RED counts with some nodes that allows working with the flow's payload using pre-configured tools or coding their behavior in JavaScript functions that can be created within the editor using a rich text editor. With this proposal, these nodes are provided with both input and output connectors.</p> <p>Output and Debug Nodes</p> <p></p> <p>These nodes only have an input connector that allows extracting data from the flow to third parties, files, or debugs console in the web editor.</p>"},{"location":"plugins/node-red/#palette","title":"Palette","text":"<p>The web editor contains a graphical list with all the available nodes that can be found in a Node-RED server, called \"palette\". in order to provide simple access when creating a flow.  You can extend your palette just using the \"palette manager\" situated at Node-RED's main menu, in which you can find more than 2.000 additional nodes for your server that have been created by both Node-RED developers and by community contributors.</p>"},{"location":"plugins/node-red/#flows","title":"Flows","text":"<p>A flow is represented as a tab within the editor workspace and is the main way to organize nodes. Each flow can have a name, and a description that is displayed in the Information sidebar. All of the nodes in a specific flow can access the same flow-scoped context.</p> <p>The flow editor makes it easy to wire together flows using the wide range of nodes in the palette. Flows can be then deployed to the runtime just clicking into \"debloy\" button:</p> <p> </p>"},{"location":"plugins/node-red/#debug-console","title":"Debug Console","text":"<p>Is a section of the right slide bar that provides a structured view of the messages that are being sent by the debug nodes,  making it easier to explore the performance of the execution.</p> <p>Alongside each message, the debug sidebar includes information about the time the message was received and which Debug node sent it. Clicking on the source node id will reveal that node within the workspace.</p> <p>Node-RED documentation</p> <p>You can find additional documentation about the use of this tool in Node-RED's official website: https://nodered.org/docs/user-guide/editor/workspace/</p>"},{"location":"plugins/node-red/#starting-with-thingerio-nodes","title":"Starting with Thinger.io Nodes","text":"<p>In this section, it is described how to configure Node-RED \"Thinger.io Nodes\" to start working with any particular Thinger.io server, that could be your own instance or the public one that is hosted on \"https://api.thinger.io\" and it is also necessary to provide an authorization to allow Node-RED to work with your Thinger.io account.</p> <p>To make this configuration, just drag any Thinger.io Node to the canvas and open its properties form, then go to the last input, called \"Server \" and click into the edition button, which will open the Thinger-Server configuration menu.</p> <p> </p> <p>This form allows you to introduce the credentials of the specific Thinger.io instance address and authorization that is going to receive your Node-RED requests. However, it is important to take care of the next considerations in order to make a proper configuration:</p> <p>Tip</p> <ul> <li> <p>If you are using Node-RED in a Thinger.io Plugin and you want to work with the same Thinger.io server that is hosting the plugin,  it is only necessary to include <code>$(THINGER_HOST)</code> into \"Host\" box and <code>$(THINGER_TOKEN_NODE_RED_PLUGIN)</code> in the \"Token\" box, then you can disable SSL communication, as all messages are going to run into the same computer.</p> </li> <li> <p>if you want to use a different Thinger.io Server or you aren't running Node-RED from a plugin, it will be necessary to include its URL or IP Address in the \"Host\" box and also a Thinger.io Access Token with Admin-Access privileges in the \"Token\" box, finally, SSL would be preferable in this case.</p> </li> </ul> <p> </p>"},{"location":"plugins/node-red/#thingerio-nodes","title":"Thinger.io Nodes","text":"<p>As it was explained in the beginning, this plugin has two purposes: Host a Node-RED server instance together with Thinger.io IoT server and improve their integration by including a set of custom nodes to simplify the extraction of data from Thinger.io IoT devices or calling other platform features. The next list contains a complete description of each node and its properties configuration:</p>"},{"location":"plugins/node-red/#asset-iterator","title":"Asset Iterator","text":"<p>It is a Function Node that iterates over all the desired assets avaible on Thinger.io Platform given a filter. It is able to receive a JSON from Node-RED flow and automatically query the backend. This node is useful to execute operations over multiple assets at the same time.</p> <p>The configuration of this Node requires introducing of at least the <code>Asset</code>.</p> <p>There will be as many output messages as assets retrieved, each containing the information to only one asset.</p>"},{"location":"plugins/node-red/#bucket-create","title":"Bucket Create","text":"<p>It is a Function Node that creates a Data Bucket into a Thinger.io Platform. It is able to receive a JSON from Node-RED flow and automatically create the Bucket, so results quite useful to implement scalable and on demand data storage to any project.</p> <p>The configuration of this Node requires introducing of at least the <code>Bucket ID</code> and <code>Data Source</code>, but allows the introduction of the same fields from the Thinger.io <code>Add Bucket</code> operation. It is important to make proper management of the node, as if it is run in a loop may create an infinite number of buckets.</p> <p>The output message will contain the result and details of the operation.</p>"},{"location":"plugins/node-red/#bucket-read","title":"Bucket Read","text":"<p>It is a Function Node that retrieves data from a specific Thinger.io Data Bucket when an injection Node requires it. It is useful to get data from buckets with a Node-RED programmed sampling interval.</p> <p>To configure this node just include the <code>Bucket ID</code>, <code>Filter</code> and <code>Sorting</code> into the node parameters form. The input for this Node is a triggered event and the output will be a JSON format message with the buckets stored data.</p>"},{"location":"plugins/node-red/#bucket-write","title":"Bucket Write","text":"<p>It is an Output Node that allows to store data into the Thinger.io Data Bucket. It is able to receive a JSON from Node-RED flow and automatically create an entry into the Bucket, so results quite useful to implement scalable data storage to any project.</p> <p>The configuration of this Node just requires introducing the <code>Bucket ID</code>, however, it is important to make proper management of the input JSON in order to store the right data. It is strongly recommended to filter the JSON keys using a \"Change\" Node and check the result with a \"Debug\" Node to be sure about the data that we are sending.</p>"},{"location":"plugins/node-red/#device-callback","title":"Device Callback","text":"<p>It is a Function Node that calls an HTTP device callback in order to send a message or retrieve what the device has configured in its callback. If the device does not exist it will manage the auto provisioning of a new device and data bucket. It is useful to get auto provision new devices based of different events save its data from the beginning.</p> <p>To configure this node just include the <code>Device ID</code> into the node parameters form or through an input message. The input for this Node is a triggered event and the output will be a JSON format message with the device callback response if any.</p>"},{"location":"plugins/node-red/#device-create","title":"Device Create","text":"<p>It is a Function Node that creates a Device into the Thinger.io Platform. It is able to receive a JSON from Node-RED flow and automatically create the Device, so results quite useful to implement scalable and on demand device creation to any project.</p> <p>The configuration of this Node requires introducing of at least the <code>Bucket ID</code>, <code>Type</code> and <code>Credentials</code> if applicable. However, allows the introduction of the same fields from the Thinger.io <code>Add Device</code> operation. It is important to make proper management of the node, as if it is run in a loop may create an infinite number of devices.</p> <p>The output message will contain the result and details of the operation.</p>"},{"location":"plugins/node-red/#device-read","title":"Device Read","text":"<p>It is a Function Node that retrieves data from a specific Thinger.io device resource when an injection Node requires it. It is useful to get data from devices with a Node-RED programmed sampling interval.</p> <p>To configure this node just include the <code>Device ID</code>and the <code>Resource Name</code> into the node parameters form. The input for this Node is a triggered event and the output will be a JSON format message with the device resource variables.</p>"},{"location":"plugins/node-red/#device-stream","title":"Device Stream","text":"<p>It is an Injection Node that retrieves data from a specific Thinger.io Device Resource on regular defined interval expressed in seconds into the properties form.</p> <p>To configure this node just include the <code>Device ID</code>and the <code>Resource Name</code> into the node parameters form. The output of this node will be a JSON with the real-time Device Resource data that was defined in the properties form.</p>"},{"location":"plugins/node-red/#device-write","title":"Device Write","text":"<p>It is a Function Node that allows sending data to a Thinger.io connected Device. It is able to receive a JSON from Node-RED flow and automatically send it to other devices in real-time. So results quite useful to implement scalable device communication for any project.</p> <p>The configuration of this Node just requires introducing the <code>Device ID</code> and the <code>Resource ID</code> , however, it is important to make proper management of the input JSON in order to store the right data. It is strongly recommended to filter the JSON keys using a \"Change\" Node and check the result with a \"Debug\" Node to be sure about the data that we are sending.</p>"},{"location":"plugins/node-red/#endpoint-call","title":"Endpoint Call","text":"<p>It is a Function Node that allows calling the execution of a Thinger.io endpoint profile. It is able to receive a JSON that can be introduced in the endpoint in order to use that data in an e-mail or send it to third parties, so it is quite useful to create notifications or to integrating an IoT project with other systems.</p> <p>The configuration of this Node just requires introducing the <code>Endpoint ID</code>, however, it is important to make a proper management of the input JSON in order to send the right data. It is strongly recommended to filter the JSON keys using a \"Change\" Node and check the result with a \"Debug\" Node to be sure about the data that we are sending.</p>"},{"location":"plugins/node-red/#property-read","title":"Property Read","text":"<p>It is a Function Node that retrieves data from a specific Thinger.io device, type or group property when an injection Node requires it. It is useful to get data from assets with a Node-RED programmed sampling interval.</p> <p>To configure this node just include the <code>Asset Type</code>, <code>Asset ID</code>and <code>Property Name</code> into the node parameters form. The input for this Node is a triggered event and the output will be a JSON format message with the asset's property value.</p>"},{"location":"plugins/node-red/#property-write","title":"Property Write","text":"<p>It is a Function Node that writes data into a specific Thinger.io device, type or group property when an injection Node requires it. It is useful to save data into assets in order to manage different configurations and act accordingly.</p> <p>To configure this node just include the <code>Asset Type</code>, <code>Asset ID</code>and <code>Property Name</code> into the node parameters form. The input for this Node is a triggered event and the output will be a JSON format message with the operation's result and details.</p>"},{"location":"plugins/node-red/#storage-read","title":"Storage Read","text":"<p>It is a Function Node that reads any file saved in a Thinger.io storage and returns it to Node-RED. It is able to read any file, returning the string representation for text files (plain, csv, json, ...) or a Buffer otherwise. Useful for retrieving and treating information or being able to pass the info to third party nodes.</p> <p>The configuration of the node requires only the <code>Storage ID</code>, as it is able to read recursively. If a <code>file path</code> is passed it will read the file content, or its details, as desired.  The input for this Node is a triggered event and the output will be a JSON format message with the operation's result and details.</p>"},{"location":"plugins/node-red/#storage-write","title":"Storage Write","text":"<p>It is an Output Node that allows to store data into the Thinger.io File Storage. It is able to receive a payload from Node-RED flow and automatically save or append into a file in the Storage, so results quite useful to implement scalable file storage to any project.</p> <p>The configuration of this Node just requires introducing the <code>Storage ID</code>, however, it is important to make proper management of the input in order to store the right data.</p>"},{"location":"plugins/node-red/#server-events","title":"Server Events","text":"<p>It is an Inject Node that allows triggering in real-time any event that takes places in Thinger.io IoT Server over all existing assets, like device, types, groups or buckets. Some events contain also additional filter fields to filter from.</p> <p>The configuration of each type requires to include the ID of the element that wants to be supervised. It is also possible to monitor every element leaving the identifier field empty.</p> <p>When any of these events is triggered, this Node is able to inject a JSON in the flow with the identifier of the Bucket, Device, or Endpoint that has produced the event along with the relevant data.</p> <p>Tip</p> <p>If you need further technical information, you can find all the details for each node in Node-RED help dialog.</p>"},{"location":"plugins/node-red/#useful-example-flows","title":"Useful Example Flows","text":"<p>In this section, you can find our own cookbook with some useful flows that you can use to get the maximum benefit from this integration</p> Device Disconnection AlertMQTT to Thinger.ioGPS GeofencesModify Incoming dataDevice creation <p>Using the \"Device Status Change\" property of the Server Event Node, it is possible to detect the disconnection of any device of your IoT network and execute a flow in Node-RED to notify the incidence using an endpoint sending an email for example.</p> <p>Warning</p> <p>Learn how to create an email endpoint here. </p> <p>The next flow uses two Thinger.io Nodes, the first one is triggering the Device Disconnection Server Event that will throw a JSON formatted message with the device ID, the status and the timestamp of the change. The second Node allows calling the Endpoint profile to send the alert with the device information JSON attached so it is possible to custom the message to easily identify the problem. </p> <p><p> </p></p> <p>This flow can be easily imported into your Node-RED workspace using the next JSON:</p> <pre><code>[{\"id\":\"d577ba5d.a271b8\",\"type\":\"tab\",\"label\":\"Device Disconnection Alert\",\"disabled\":false,\"info\":\"\"},{\"id\":\"b5b501a2.a5287\",\"type\":\"server-events\",\"z\":\"d577ba5d.a271b8\",\"name\":\"\",\"asset\":\"\",\"event\":\"device_state_change\",\"filter\":\"\",\"filters\":{\"state\":\"disconnected\"},\"bucket\":\"\",\"device\":\"\",\"endpoint\":\"\",\"state\":\"disconnected\",\"server\":\"ec0dd4b1ef5aa9a8\",\"x\":231,\"y\":158.99999809265137,\"wires\":[[\"6fd24968.0dc1b8\"]]},{\"id\":\"6fd24968.0dc1b8\",\"type\":\"endpoint-call\",\"z\":\"d577ba5d.a271b8\",\"name\":\"\",\"endpoint\":\"DisconnectionAlert\",\"server\":\"ec0dd4b1ef5aa9a8\",\"x\":481,\"y\":158.99999809265137,\"wires\":[[]]},{\"id\":\"ec0dd4b1ef5aa9a8\",\"type\":\"thinger-server\",\"host\":\"$(THINGER_HOST)\",\"name\":\"local\",\"ssl\":false}]\n</code></pre> <p>Note that, the <code>Device ID</code> parameter of the Server Event Node is empty, in order to monitor the status of every device in our network. The green indicator under this Node represents the connection status between Node-RED and Thinger.io server.  </p> <p>MQTT is an extended communication protocol  in IoT that works on top of the TCP/IP protocol suite. It is designed for connections with remote locations where a \"small code footprint\" is required or the network bandwidth is limited. The next flow allows sending data from a device hosted by NodeRED MQTT Server to the REST API Callback of a Thinger.io HTTP device, in order to store, analyze an show that information with Thinger.io features.   </p> <p>Info</p> <p>Learn how to work with Thinger.io HTTP device callback here</p> <p><p> </p></p> <p>This flow can be easily imported into your Node-RED workspace using the next JSON:</p> <pre><code>[{\"id\":\"a3d8dc1f.2ef57\",\"type\":\"tab\",\"label\":\"MQTT to Thinger.io\",\"disabled\":false,\"info\":\"\"},{\"id\":\"ce84849f.8d4278\",\"type\":\"mqtt in\",\"z\":\"a3d8dc1f.2ef57\",\"name\":\"MQTT Device\",\"topic\":\"Device\",\"qos\":\"2\",\"datatype\":\"json\",\"broker\":\"79cc5157a4c20036\",\"nl\":false,\"rap\":false,\"inputs\":0,\"x\":193.0000114440918,\"y\":139.99999332427979,\"wires\":[[\"af229fc2.2759a\"]]},{\"id\":\"af229fc2.2759a\",\"type\":\"function\",\"z\":\"a3d8dc1f.2ef57\",\"name\":\"Json Creator\",\"func\":\"msg.payload = {\\\"temperatura1\\\":msg.payload};\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[],\"x\":352.9999771118164,\"y\":139.99999332427979,\"wires\":[[\"14bff97cb9a4beca\"]]},{\"id\":\"da89c2c1.ce839\",\"type\":\"debug\",\"z\":\"a3d8dc1f.2ef57\",\"name\":\"Check Result\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"true\",\"targetType\":\"full\",\"x\":750,\"y\":140,\"wires\":[]},{\"id\":\"14bff97cb9a4beca\",\"type\":\"device-callback\",\"z\":\"a3d8dc1f.2ef57\",\"name\":\"\",\"device\":\"temperature sensor\",\"body\":\"\",\"server\":\"ec0dd4b1ef5aa9a8\",\"x\":550,\"y\":140,\"wires\":[[\"da89c2c1.ce839\"]]},{\"id\":\"79cc5157a4c20036\",\"type\":\"mqtt-broker\",\"name\":\"\",\"broker\":\"localhost\",\"port\":\"1883\",\"clientid\":\"\",\"autoConnect\":true,\"usetls\":false,\"protocolVersion\":\"4\",\"keepalive\":\"60\",\"cleansession\":true,\"birthTopic\":\"\",\"birthQos\":\"0\",\"birthPayload\":\"\",\"birthMsg\":{},\"closeTopic\":\"\",\"closeQos\":\"0\",\"closePayload\":\"\",\"closeMsg\":{},\"willTopic\":\"\",\"willQos\":\"0\",\"willPayload\":\"\",\"willMsg\":{},\"userProps\":\"\",\"sessionExpiry\":\"\"},{\"id\":\"ec0dd4b1ef5aa9a8\",\"type\":\"thinger-server\",\"host\":\"$(THINGER_HOST)\",\"name\":\"local\",\"ssl\":false}]\n</code></pre> <p>Note that his is an easy example that only retrieves data from just one MQTT device, however it is possible to create complex integrations</p> <p>Geofencing is an interesting IoT use case, with many applications in asset management, fleets or package tracking. The next flow shows how to monitor the location of any device to create an alert when it leaves an area specified with a Geofence Node.  </p> <p><p> </p></p> <p>Creating this integration with the \"device_location\" property, it is possible to integrate any kind of device including Thinger.io Software Clients, Sigfox, TTN or even HTTP devices in a very simple way.</p> <p>Info</p> <p>Learn how to create an email endpoint here. </p> <p>This flow can be easily imported into your Node-RED workspace using the next JSON:</p> <pre><code>[{\"id\":\"5f747490.ef8edc\",\"type\":\"tab\",\"label\":\"GPS Geofences\",\"disabled\":false,\"info\":\"\"},{\"id\":\"207937f8.10dc48\",\"type\":\"server-events\",\"z\":\"5f747490.ef8edc\",\"name\":\"\",\"asset\":\"\",\"event\":\"device_callback_call\",\"filter\":\"\",\"filters\":{},\"bucket\":\"\",\"device\":\"\",\"endpoint\":\"\",\"state\":\"\",\"server\":\"ec0dd4b1ef5aa9a8\",\"x\":158.60000228881836,\"y\":264.00000381469727,\"wires\":[[\"8f3dd8cd.71e4e8\",\"56adf62.4aa1108\"]]},{\"id\":\"553ff10.2e60c1\",\"type\":\"geofence\",\"z\":\"5f747490.ef8edc\",\"name\":\"\",\"mode\":\"polyline\",\"inside\":\"false\",\"rad\":0,\"points\":[{\"latitude\":39.89203705190782,\"longitude\":-3.8814695924520493},{\"latitude\":40.06041580712444,\"longitude\":-3.507934436202049},{\"latitude\":40.09404176311921,\"longitude\":-3.0025633424520493},{\"latitude\":41.14474248673421,\"longitude\":-3.5299070924520493},{\"latitude\":40.253538217286675,\"longitude\":-4.628539904952049},{\"latitude\":40.102445657515226,\"longitude\":-3.771606311202049}],\"centre\":{},\"floor\":\"\",\"ceiling\":\"\",\"worldmap\":false,\"outputs\":1,\"x\":573.0000076293945,\"y\":265.0000276565552,\"wires\":[[\"be251c21.6d6e3\",\"233f843b.94472c\"]]},{\"id\":\"be251c21.6d6e3\",\"type\":\"endpoint-call\",\"z\":\"5f747490.ef8edc\",\"name\":\"\",\"endpoint\":\"alert\",\"server\":\"ec0dd4b1ef5aa9a8\",\"x\":771.6000595092773,\"y\":266.0000286102295,\"wires\":[[]]},{\"id\":\"8f3dd8cd.71e4e8\",\"type\":\"debug\",\"z\":\"5f747490.ef8edc\",\"name\":\"\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"false\",\"x\":399.6000061035156,\"y\":346.00000762939453,\"wires\":[]},{\"id\":\"233f843b.94472c\",\"type\":\"debug\",\"z\":\"5f747490.ef8edc\",\"name\":\"\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"false\",\"x\":790.6000366210938,\"y\":347.0000057220459,\"wires\":[]},{\"id\":\"56adf62.4aa1108\",\"type\":\"change\",\"z\":\"5f747490.ef8edc\",\"name\":\"\",\"rules\":[{\"t\":\"set\",\"p\":\"payload\",\"pt\":\"msg\",\"to\":\"payload.payload\",\"tot\":\"msg\"}],\"action\":\"\",\"property\":\"\",\"from\":\"\",\"to\":\"\",\"reg\":false,\"x\":389.6000061035156,\"y\":265.00000381469727,\"wires\":[[\"553ff10.2e60c1\"]]},{\"id\":\"ec0dd4b1ef5aa9a8\",\"type\":\"thinger-server\",\"host\":\"$(THINGER_HOST)\",\"name\":\"local\",\"ssl\":false}]\n</code></pre> <p>In some situations it is required to change the unit or metric of any variable, it is now possible to make this transformations before store data in a data bucket by use this Node-RED flow:</p> <p><p> </p></p> <p>The configuration is quite simple, fist node retrieves the measurement of any device to be modified by the \"function\" node, that contains the codification that has been included below, and finally the \"bucket write\" node allows storing the transformed data.</p> <p>The codification of the function node is:</p> <pre><code>msg.payload = {\"KW\":msg.payload.payload.wats/1000};\nmsg.topic=msg.payload.device;\nreturn msg;\n</code></pre> <p>The next json contains this flow in order to be imported:</p> <pre><code>[{\"id\":\"bcfa644f1bf43d03\",\"type\":\"tab\",\"label\":\"Modify Incoming data\",\"disabled\":false,\"info\":\"\"},{\"id\":\"3310aff0318c010d\",\"type\":\"server-events\",\"z\":\"bcfa644f1bf43d03\",\"name\":\"\",\"asset\":\"\",\"event\":\"device_callback_call\",\"filter\":\"\",\"filters\":{},\"bucket\":\"\",\"device\":\"\",\"endpoint\":\"\",\"state\":\"\",\"server\":\"ec0dd4b1ef5aa9a8\",\"x\":290,\"y\":140,\"wires\":[[\"d50d939aa230b928\"]]},{\"id\":\"d50d939aa230b928\",\"type\":\"function\",\"z\":\"bcfa644f1bf43d03\",\"name\":\"W to KW\",\"func\":\"msg.payload = {\\\"KW\\\":msg.payload.payload.wats/1000};\\nmsg.id=msg.payload.device;\\nreturn msg;\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[],\"x\":480,\"y\":140,\"wires\":[[\"f6cc88d04b1b8cf8\"]]},{\"id\":\"f6cc88d04b1b8cf8\",\"type\":\"bucket-write\",\"z\":\"bcfa644f1bf43d03\",\"name\":\"\",\"bucket\":\"\",\"value\":\"\",\"server\":\"ec0dd4b1ef5aa9a8\",\"x\":650,\"y\":140,\"wires\":[]},{\"id\":\"ec0dd4b1ef5aa9a8\",\"type\":\"thinger-server\",\"host\":\"$(THINGER_HOST)\",\"name\":\"local\",\"ssl\":false}]\n</code></pre> <p>With the \"Device create\" and \"Bucket create\" nodes it is possible to create multiple devices, with the same or different credentials, types or groups; and create buckets associated to the recently created devices.</p> <p><p> </p></p> <p>This flow can be easily imported into your Node-RED workspace using the next JSON:</p> <pre><code>[{\"id\":\"a4b9f2e08c15ad79\",\"type\":\"tab\",\"label\":\"Device creation\",\"disabled\":false,\"info\":\"\",\"env\":[]},{\"id\":\"507f1a24287e53e2\",\"type\":\"function\",\"z\":\"a4b9f2e08c15ad79\",\"name\":\"loop - 10 devices\",\"func\":\"let device = msg.device;\\n\\nfor (let i= 0; i &lt; 10; i++) {\\n    msg.device = `${device}_${i}`;\\n    msg.name = `${device} ${i}`;\\n    msg.description = \\\"Device auto generated from Node-RED flow\\\";\\n    node.send(msg);\\n}\",\"outputs\":1,\"noerr\":0,\"initialize\":\"\",\"finalize\":\"\",\"libs\":[],\"x\":490,\"y\":220,\"wires\":[[\"752ee26eb02bed51\"]]},{\"id\":\"415e0ad528c64866\",\"type\":\"inject\",\"z\":\"a4b9f2e08c15ad79\",\"name\":\"inject device name\",\"props\":[{\"p\":\"device\",\"v\":\"climastick\",\"vt\":\"str\"}],\"repeat\":\"\",\"crontab\":\"\",\"once\":false,\"onceDelay\":0.1,\"topic\":\"\",\"x\":270,\"y\":220,\"wires\":[[\"507f1a24287e53e2\"]]},{\"id\":\"752ee26eb02bed51\",\"type\":\"device-create\",\"z\":\"a4b9f2e08c15ad79\",\"name\":\"\",\"deviceType\":\"Generic\",\"deviceId\":\"\",\"deviceCredentials\":\"&amp;Xzi3LlG&amp;lyaoyO2\",\"deviceName\":\"\",\"description\":\"\",\"assetType\":\"temperature\",\"assetGroup\":\"house\",\"server\":\"ec0dd4b1ef5aa9a8\",\"x\":690,\"y\":220,\"wires\":[[\"e1da854b042efd77\"]]},{\"id\":\"69d16e383e46acd9\",\"type\":\"debug\",\"z\":\"a4b9f2e08c15ad79\",\"name\":\"debug\",\"active\":true,\"tosidebar\":true,\"console\":false,\"tostatus\":false,\"complete\":\"true\",\"targetType\":\"full\",\"statusVal\":\"\",\"statusType\":\"auto\",\"x\":715,\"y\":300,\"wires\":[],\"l\":false},{\"id\":\"3be83c6bcc65f1cb\",\"type\":\"comment\",\"z\":\"a4b9f2e08c15ad79\",\"name\":\"Create 10 device and assign a bucket to all of them\",\"info\":\"This node creates 10 devices in Thinger.io Platform, in this case climasticks, from 0 to 9; all of them with the same credentials, type and group. Also, 10 buckets are created with the date source being the devices created.\\n\\n### Device create node\\nThe device id, name and description are passed as input to the device create node, while the credentials, type and group is configured through the device create node dialog.\\n\\n### Bucket create node\\nThe id, bucket name and description are passed as input to the bucket create node, as well as the extra source (the device in this case) for the data source.\\nThe source (device), resource, update interval and asset type and group are configured through the bucket create node dialog.\",\"x\":350,\"y\":160,\"wires\":[]},{\"id\":\"05af9a7c2958e6c6\",\"type\":\"bucket-create\",\"z\":\"a4b9f2e08c15ad79\",\"name\":\"\",\"bucketId\":\"\",\"bucket\":\"\",\"description\":\"\",\"enabled\":true,\"source\":\"device\",\"extraSource\":\"\",\"resource\":\"temperature\",\"update\":\"interval\",\"interval\":\"1m\",\"assetType\":\"temperature\",\"assetGroup\":\"house\",\"server\":\"ec0dd4b1ef5aa9a8\",\"x\":570,\"y\":300,\"wires\":[[\"69d16e383e46acd9\"]]},{\"id\":\"e1da854b042efd77\",\"type\":\"change\",\"z\":\"a4b9f2e08c15ad79\",\"name\":\"Reorder message to create bucket\",\"rules\":[{\"t\":\"delete\",\"p\":\"payload\",\"pt\":\"msg\"},{\"t\":\"set\",\"p\":\"id\",\"pt\":\"msg\",\"to\":\"device\",\"tot\":\"msg\"},{\"t\":\"move\",\"p\":\"name\",\"pt\":\"msg\",\"to\":\"bucket\",\"tot\":\"msg\"}],\"action\":\"\",\"property\":\"\",\"from\":\"\",\"to\":\"\",\"reg\":false,\"x\":320,\"y\":300,\"wires\":[[\"05af9a7c2958e6c6\"]]},{\"id\":\"ec0dd4b1ef5aa9a8\",\"type\":\"thinger-server\",\"host\":\"$(THINGER_HOST)\",\"name\":\"local\",\"ssl\":false}]\n</code></pre> <p>Info</p> <p>Learn how to create devices here, and data buckets here</p>"},{"location":"plugins/node-red/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"plugins/node-red/changelog/#161-2---2023-11-30","title":"1.6.1-2 - 2023-11-30","text":""},{"location":"plugins/node-red/changelog/#changed","title":"Changed","text":"<ul> <li>node-red-contrib-thinger with Node.js version 18</li> </ul>"},{"location":"plugins/node-red/changelog/#161-1---2023-11-30","title":"1.6.1-1 - 2023-11-30","text":""},{"location":"plugins/node-red/changelog/#changed_1","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.6.1</li> <li>Downgrade Node.js to version 16</li> </ul>"},{"location":"plugins/node-red/changelog/#160-1---2023-11-29","title":"1.6.0-1 - 2023-11-29","text":""},{"location":"plugins/node-red/changelog/#changed_2","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.6.0</li> <li>Bumped Node.js to version 18</li> </ul>"},{"location":"plugins/node-red/changelog/#151-1---2023-11-24","title":"1.5.1-1 - 2023-11-24","text":""},{"location":"plugins/node-red/changelog/#changed_3","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.5.1</li> </ul>"},{"location":"plugins/node-red/changelog/#150-1---2023-11-15","title":"1.5.0-1 - 2023-11-15","text":""},{"location":"plugins/node-red/changelog/#changed_4","title":"Changed","text":"<ul> <li>Bumped node-red to 3.1.0</li> <li>Bumped node-red-contrib-thinger to 1.5.0</li> </ul>"},{"location":"plugins/node-red/changelog/#143-1---2023-02-09","title":"1.4.3-1 - 2023-02-09","text":""},{"location":"plugins/node-red/changelog/#changed_5","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.4.3</li> </ul>"},{"location":"plugins/node-red/changelog/#142---2023-02-01","title":"1.4.2 - 2023-02-01","text":""},{"location":"plugins/node-red/changelog/#changed_6","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.4.2</li> </ul>"},{"location":"plugins/node-red/changelog/#141---2022-09-05","title":"1.4.1 - 2022-09-05","text":""},{"location":"plugins/node-red/changelog/#changed_7","title":"Changed","text":"<ul> <li>Bumped node-red to 3.0.2</li> <li>Bumped node-red-contrib-thinger to 1.4.1</li> </ul>"},{"location":"plugins/node-red/changelog/#140---2022-07-27","title":"1.4.0 - 2022-07-27","text":""},{"location":"plugins/node-red/changelog/#changed_8","title":"Changed","text":"<ul> <li>Bumped node-red to 3.0.1</li> <li>Bumped node-red-contrib-thinger to 1.4.0</li> <li>Updated Node.js to version 16</li> </ul>"},{"location":"plugins/node-red/changelog/#132---2022-03-14","title":"1.3.2 - 2022-03-14","text":""},{"location":"plugins/node-red/changelog/#changed_9","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.3.2</li> </ul>"},{"location":"plugins/node-red/changelog/#131---2022-02-01","title":"1.3.1 - 2022-02-01","text":""},{"location":"plugins/node-red/changelog/#changed_10","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.3.1</li> <li>Bumped Node-RED version to 2.1.6</li> </ul>"},{"location":"plugins/node-red/changelog/#130---2021-12-22","title":"1.3.0 - 2021-12-22","text":""},{"location":"plugins/node-red/changelog/#changed_11","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.3.0</li> </ul>"},{"location":"plugins/node-red/changelog/#123---2021-11-24","title":"1.2.3 - 2021-11-24","text":""},{"location":"plugins/node-red/changelog/#changed_12","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.2.3</li> <li>Set module version in dockerfile to avoid docker image layer caching</li> </ul>"},{"location":"plugins/node-red/changelog/#122---2021-11-23","title":"1.2.2 - 2021-11-23","text":""},{"location":"plugins/node-red/changelog/#changed_13","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.2.2</li> </ul>"},{"location":"plugins/node-red/changelog/#121---2021-11-22","title":"1.2.1 - 2021-11-22","text":""},{"location":"plugins/node-red/changelog/#changed_14","title":"Changed","text":"<ul> <li>Bumped node-red-contrib-thinger to 1.2.1</li> </ul>"},{"location":"plugins/node-red/changelog/#120---2021-11-22","title":"1.2.0 - 2021-11-22","text":""},{"location":"plugins/node-red/changelog/#changed_15","title":"Changed","text":"<ul> <li>Updated Node-RED version to 2.1.3</li> <li>Updated Node.js to version 14</li> <li>Bumped node-red-contrib-thinger to 1.2.0</li> </ul>"},{"location":"plugins/node-red/changelog/#110---2021-09-14","title":"1.1.0 - 2021-09-14","text":""},{"location":"plugins/node-red/changelog/#changed_16","title":"Changed","text":"<ul> <li>Updated Node-RED version to 2.0.6</li> <li>Updated Node.js to version 14</li> <li>Installation from npm instead of repository</li> </ul>"},{"location":"plugins/node-red/changelog/#102---2020-07-10","title":"1.0.2 - 2020-07-10","text":""},{"location":"plugins/node-red/changelog/#changed_17","title":"Changed","text":"<ul> <li>Updated Node-Red version to 12</li> </ul>"},{"location":"plugins/node-red/changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed events node to properly register filters for buckets and endpoints</li> </ul>"},{"location":"plugins/prometheus/","title":"Prometheus","text":"<p>Prometheus is an open-source monitoring system and time series database that allows you to collect and store metrics about your infrastructure and applications, and provides a powerful query language called PromQL that you can use to analyze and graph these metrics.</p> <p>Prometheus also provides a range of other features, including alerting, graphing, and visualization.</p> <p>One of the key features of Prometheus is its ability to scrape data from targets using a simple HTTP-based protocol. This means that you can easily configure Prometheus to monitor your infrastructure, in this case Thinger.io.</p> <p>By utilizing both the Prometheus Exporter Plugin and the Prometheus Server Plugin, you gain the ability to assess the status of Thinger.io and its resources through database queries. Moreover, this integration extends its functionality to enable monitoring of external systems.</p>"},{"location":"plugins/prometheus/#get-started","title":"Get Started","text":"<p>When installing the Prometheus Plugin, a new file storage is created called 'Prometheus Settings'. This file storage contains a template of the configuration in order to scrape the Prometheus Exporter Plugin endpoint.</p> <p>In order for the connection to take place, edit the file by introducing your details and restart the plugin.</p> <p>This file can also be used to configure external systems scraping.</p> <p>Note</p> <p>Check out also the Alertmanager plugin</p> <p> </p>"},{"location":"plugins/prometheus/#integration-with-grafana","title":"Integration with Grafana","text":"<p>Grafana provides native support for Prometheus, therefore, we can configure a connection between the two plugins.</p> <p>Note</p> <p>Refer to the Grafana plugin page if you need more details on how to get started</p> <p>Once grafana in installed and logged in, you may go to 'Settings'-&gt;'Data sources'. Click on <code>Add data source</code> and click on 'Prometheus'. The data to configure the Prometheus as data source you'll need: - URL: http://-prometheus:9090/users//plugins/prometheus <p>And thats it, you may start now creating dashboard in grafana with prometheus as the backend.</p> <p> </p>"},{"location":"plugins/prometheus/#official-documentation","title":"Official Documentation","text":"<p>The Prometheus documentation is available at prometheus.io/docs.</p> <p>More details regarding the configuration of Prometheus at this link.</p> <p>Note</p> <p>Any configuration change in <code>prometheus.yml</code> requires a restart of the Prometheus plugin.</p>"},{"location":"plugins/prometheus/#license","title":"License","text":"<p>Prometheus is distributed under the Apache 2.0 License.</p>"},{"location":"plugins/prometheus/changelog/","title":"Changelog","text":""},{"location":"plugins/prometheus/changelog/#2460-1---2023-08-31","title":"2.46.0-1 - 2023-08-31","text":"<ul> <li>Create and upload Prometheus plugin</li> </ul>"},{"location":"plugins/prometheus-exporter/","title":"Prometheus Exporter","text":"<p>The Thinger.io Prometheus Exporter plugin is designed to facilitate the monitoring of your Thinger.io resources. It allows you to expose metrics in Prometheus formats through a dedicated endpoint.</p> <p>This exporter provides you with the flexibility to define and configure metrics according to your requirements. It supports dynamic value extraction from three available backends:</p> <ul> <li>Thinger.io Database</li> <li>Data Buckets (Coming soon)</li> <li>Thinger.io API (Coming soon)</li> </ul>"},{"location":"plugins/prometheus-exporter/#getting-started","title":"Getting Started","text":"<p>To start out with this plugin, the Default application might be used or a new one created, by selecting <code>New Application...</code> in the dropdown.</p> <p>To create a metric, click on the <code>+Add</code> button in the right top corner of the metrics table, where a modal form will open.</p> <p>Here you can find an example for a metric that tracks the total of devices with their status:</p> <ul> <li>Name: devices_total</li> <li>Help string: number of devices</li> <li>Labels: status</li> </ul> <p>Script - Type: Gauge - Backend: Thinger.io Database - Source:   <pre><code>const connected = db.collection('devices').countDocuments({ \"enabled\": true, \"connection.active\": { \"$eq\": true }});\nconst disconnected = db.collection('devices').countDocuments({ \"enabled\": true, \"connection.active\": { \"$eq\": false }});\nconst disabled = db.collection('devices').countDocuments({ \"enabled\": false});\n\nconst values  = await Promise.all([connected, disconnected, disabled]);\nmetric.set({ status: 'connected'}, values[0]);\nmetric.set({ status: 'disconnected'}, values[1]);\nmetric.set({ status: 'disabled'}, values[2]);\n</code></pre></p> <p>Each metric can be tested out individually, and once validated and saved, the full application endpoint can be queried, through the <code>Endpoint Settings</code> tab, where all needed configuration to create a Prometheus scrape job can be found.</p> <p></p>"},{"location":"plugins/prometheus-exporter/#additional-resources","title":"Additional Resources","text":"<p>Given that the plugin is based and developed with Prometheus in mind, you may refer to Prometheus official documentation, and more specifically to the Data Model.</p> <p>Metrics are configured using the unofficial Prometheus client for Node.js, coded through the gui of the plugin.</p> <p>Also, the Prometheus Server Plugin is available within Thinger.io.</p>"},{"location":"plugins/prometheus-exporter/#license","title":"License","text":"<p>The class is licensed under the MIT License:</p> <p>Copyright \u00a9 Thinger.io</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"plugins/prometheus-exporter/changelog/","title":"Changelog","text":""},{"location":"plugins/prometheus-exporter/changelog/#110---2023-06-20","title":"1.1.0 - 2023-06-20","text":"<ul> <li>Logging added for each endpoint and individual query with timestamp and performance</li> </ul>"},{"location":"plugins/prometheus-exporter/changelog/#100---2023-04-04","title":"1.0.0 - 2023-04-04","text":"<ul> <li>First version of plugin with access to Thinger.io Database</li> </ul>"},{"location":"plugins/sftpgo/","title":"SFTPGo","text":"<p>SFTPGo extends capabilities of File Storages, adding support for SFTP, FTP and FTPS with individual user management. With this plugin you can leverage Thinger.io file storage backends for exchanging and storing files on the platform.</p>"},{"location":"plugins/sftpgo/#get-started","title":"Get Started","text":"<p>SFTPGo has two different Web UIs, separated by admin and client users. To access them, as usually after installation, a new option will appear under the Plugins section on the left toolbar to acess SFTPGo.</p> <p>When loaded, the WebClient will appear, but before being able to login with a user, we should login with the admin.</p> <p> </p> <p>Click on the WebAdmin link and enter as username and password your Thinger.io username.</p> <p> </p> <p>Important</p> <p>It is highly recommended to change the admin password to the same of the Thinger.io account or to one of your choice.</p>"},{"location":"plugins/sftpgo/#creating-users","title":"Creating Users","text":"<p>Just after a login in with the admin user, the users management menu appears. In this menu, users for transfering data may be created by following two different approaches for their shared data.</p>"},{"location":"plugins/sftpgo/#use-a-subdirectory-of-a-common-file-storage","title":"Use a subdirectory of a common file storage","text":"<p>When installing this plugin, a new file storage was created in Thinger.io with the id 'sftpgo_data', this storage may be used for SFTPGo backups and users data, so no home directory will need to be specified when creating the user, and any new files added will be added under the file storage 'sftpgo_data', in the path <code>/data/&lt;username&gt;</code>.</p> <p>We can then upload an example file and if we go to said file storage we will see the file structure.</p> <p> </p>"},{"location":"plugins/sftpgo/#user-an-already-created-file-storage","title":"User an already created file storage","text":"<p>When creating a user to share the files of an already existing file storage, the home directory of the new user needs to be specified.</p> <p>All storages will be mounted in <code>/srv/sftpgo/</code>, and to that path we would need to append the id of our storage. Example in the below screen.</p> <p> </p>"},{"location":"plugins/sftpgo/#establish-a-connection","title":"Establish a Connection","text":""},{"location":"plugins/sftpgo/#sftp","title":"SFTP","text":"<p>SFTP protocol should be the prefered option to use due to various reasons like its security, firewall friendliness and consistency.</p> <p>In order to connect with this protocol, the connection parameters are:</p> <ul> <li>Hostname: hostname of the Thinger.io instance or public IP</li> <li>Port: 2022</li> <li>Credentials: user and password for a created user</li> </ul>"},{"location":"plugins/sftpgo/#ftp-and-ftps","title":"FTP and FTPS","text":"<p>Warning</p> <p>It is recommended to always use SFTP protocol due to the design challenges of FTP/S</p> <p>For FTP and FTP over TLS (FTPS) the supported connection is in Passive Mode. The upgrade to TLS of the control and data ports may be handled automatically by the FTP client using explicit FTP.</p> <p>Tip</p> <p>Currently, only one data connection may be opened simultaneously</p> <p>The connection parameters are:</p> <ul> <li>Hostname: hostname of the Thinger.io instance or public IP</li> <li>Port: 2021</li> <li>Credentials: user and password for a created user</li> </ul> <p>On connection with an explicit FTP over TLS, the secure connection will be upgraded on both control and data ports.</p> <p>This plugin only supports the TLS connection over the base domain name of the instance.</p> <p>Warning</p> <p>If the TLS connection is not longer able to be established, restart the plugin manually in order for the certificates to reload</p>"},{"location":"plugins/sftpgo/#official-documentation","title":"Official Documentation","text":"<p>This plugin is based on the software SFTPGo. It's official documentation can be found under the docs folder in its official repository.</p>"},{"location":"plugins/sftpgo/#license","title":"License","text":"<p>SFTPGo is distributed under the AGPL-3.0 License</p>"},{"location":"plugins/sftpgo/changelog/","title":"Changelog","text":""},{"location":"plugins/sftpgo/changelog/#254-1---2023-10-24","title":"2.5.4-1 - 2023-10-24","text":"<ul> <li>Initial version</li> </ul>"},{"location":"plugins/shelly-1l/","title":"Shelly 1L","text":"<p>The Shelly 1L is a small and compact Wi-Fi smart switch that enables you to control your lights, appliances, or any other electrical device remotely.</p>"},{"location":"plugins/shelly-1l/#key-features","title":"Key Features","text":"<ul> <li>Compact design: The Shelly 1L has a small size, which makes it easy to fit in any electrical box and behind a switch or power socket, without blocking other outlets.</li> <li>Remote control: You can control your electrical devices remotely using the Shelly Cloud app on your smartphone or tablet. The app enables you to switch your devices on and off, set schedules, and monitor energy usage.</li> <li>Voice control: The Shelly 1L is compatible with Amazon Alexa, Google Home, and Apple HomeKit, so you can control your devices using voice commands.</li> <li>Energy monitoring: The Shelly 1L has an energy monitoring feature that allows you to track the energy usage of your devices, so you can make informed decisions about your energy consumption.</li> <li>Overload protection: The Shelly 1L has built-in overload protection to prevent damage to your devices in case of a power surge.</li> </ul>"},{"location":"plugins/shelly-1l/#technical-specifications","title":"Technical Specifications","text":"<ul> <li>Power supply: 110-240V AC, 50/60Hz</li> <li>Maximum load: 16A/3500W (resistive)</li> <li>Wireless connectivity: Wi-Fi 802.11 b/g/n (2.4 GHz)</li> <li>Dimensions: 41mm x 36mm x 17mm</li> <li>Operating temperature: -40\u00b0C to +40\u00b0C</li> <li>Operating humidity: 5% to 95% non-condensing</li> <li>Certification: CE, RoHS</li> </ul>"},{"location":"plugins/shelly-1l/changelog/","title":"Changelog","text":""},{"location":"plugins/shelly-1l/changelog/#100---2023-03-31","title":"1.0.0 - 2023-03-31","text":"<ul> <li>First version of plugin</li> </ul>"},{"location":"plugins/shelly-em/","title":"Shelly EM","text":"<p>Shelly EM is a Wi-Fi-operated energy meter with contactor control. It allows you to simultaneously monitor the consumption of any home appliances, electric circuits, and office equipment (lights, power lines, security systems, heating, cooling, etc.) in 2 circuits on the same phase or individually. Shelly EM is perfect for measuring solar energy production, monitoring household consumption, and controlling heavier-load appliances.</p> <p>Checkout the official documentation of the Shelly EM at this link</p>"},{"location":"plugins/shelly-em/#key-features","title":"Key Features","text":"<ul> <li>Compact design: The Shelly EM has a small size, which makes it easy to fit in any electrical box and behind a switch or power socket, without blocking other outlets.</li> <li>Power Monitoring: Shelly EM monitors monophase electrical systems with up to 2 points simultaneously. </li> <li>Contactor control: Shelly EM has an integrated relay with a rated current of 2A per output for contactor control.</li> </ul>"},{"location":"plugins/shelly-em/#technical-specifications","title":"Technical Specifications","text":"<ul> <li>Power supply: Power supply AC 110-230V \u00b110%, 50/60Hz</li> <li>Contactor contro: Yes \u2013 Shelly EM has an integrated relay with a rated current of 2A per output for contactor control</li> <li>Overload protection: No</li> <li>Maximum load: 16A/3500W (resistive)</li> <li>Wireless connectivity: Wi-Fi 802.11 b/g/n (2.4 GHz)</li> <li>Radiofrequency: 2400 \u2013 2500 MHz</li> <li>Dimensions: 39mm x 36mm x 17 mm</li> <li>Operating temperature: -0 to + 40 \u00b0C</li> </ul>"},{"location":"plugins/shelly-em/changelog/","title":"Changelog","text":""},{"location":"plugins/shelly-em/changelog/#100---2023-10-09","title":"1.0.0 - 2023-10-09","text":"<ul> <li>First version of plugin</li> </ul>"},{"location":"plugins/shelly-plug-s/","title":"Shelly Plug S","text":"<p>Shelly Plug can automatically monitor and control lighting, heating and any other connected electrical appliance at home, no matter where you are. When an electric appliance, or a lamp, is plugged into Shelly Plug, you can switch it on and off through the Shelly Cloud app at any time and anywhere.</p>"},{"location":"plugins/shelly-plug-s/#features","title":"Features","text":"<ul> <li>No HUB required.</li> <li>With Shelly Plug S you can control a wide range of devices and appliances.</li> <li>Shelly Plug S has an integrated precise power meter.</li> <li>It can be integrated to work with all other Shelly devices.</li> <li>Compatible with Android, iOS, Amazon Alexa, Google Assistant, and home automation servers using MQTT, CoAP, and REST API.</li> <li>Easily make your Arduino project live and usable in your automation project.</li> </ul>"},{"location":"plugins/shelly-plug-s/#technical-specifications","title":"Technical Specifications","text":"<ul> <li>Power supply: 110-230V AC, 50/60Hz</li> <li>Maximum load: 10A</li> <li>Wireless connectivity: Wi-Fi 802.11 b/g/n (2.4 GHz)</li> <li>Dimensions: 46mm x 69mm</li> <li>Operating temperature: -10\u00b0C to +50\u00b0C</li> <li>Certification: CE</li> </ul>"},{"location":"plugins/shelly-plug-s/changelog/","title":"Changelog","text":""},{"location":"plugins/shelly-plug-s/changelog/#100---2023-03-31","title":"1.0.0 - 2023-03-31","text":"<ul> <li>First version of plugin</li> </ul>"},{"location":"plugins/shelly-plus-1pm/","title":"Shelly Plus 1PM","text":"<p>Shelly Plus 1PM is a Wi-Fi enabled smart switch designed for efficient control of your home's electrical appliances. With power metering capabilities, it provides real-time energy consumption tracking and seamless integration with various smart home ecosystems.</p>"},{"location":"plugins/shelly-plus-1pm/#key-features","title":"Key Features","text":"<ul> <li>Real-time power consumption monitoring</li> <li>Overload and overtemperature protection</li> <li>Wide range of input voltages (110-240V AC)</li> <li>Compatible with Amazon Alexa, Google Assistant, and other smart home platforms</li> <li>Secure and encrypted communication</li> </ul>"},{"location":"plugins/shelly-plus-1pm/#technical-specifications","title":"Technical Specifications","text":"<ul> <li>Input voltage: 110-240V AC, 50/60Hz</li> <li>Max load: 16A (resistive)</li> <li>Wi-Fi: 802.11 b/g/n (2.4 GHz)</li> <li>Power metering accuracy: \u00b10.5%</li> <li>Operating temperature: -10\u00b0C to +40\u00b0C</li> <li>Dimensions: 42mm x 36mm x 17mm</li> <li>Enclosure: UL94V-0 flame retardant polymer</li> </ul>"},{"location":"plugins/shelly-plus-1pm/changelog/","title":"Changelog","text":""},{"location":"plugins/shelly-plus-1pm/changelog/#200---2023-07-13","title":"2.0.0 - 2023-07-13","text":""},{"location":"plugins/shelly-plus-1pm/changelog/#added","title":"Added","text":"<ul> <li>Support for Shelly Gen2 Protocol</li> </ul>"},{"location":"plugins/shelly-plus-1pm/changelog/#100---2023-03-31","title":"1.0.0 - 2023-03-31","text":"<ul> <li>First version of plugin for Shelly Gen1 Protocol</li> </ul>"},{"location":"plugins/sigfox/","title":"Sigfox","text":"<p>This plugin is an interface for using Sigfox HTTP Callback feature in an optimized way, providing features to easily integrate these devices with Thinger.io Platform, such as automatic device and storage provisioning and both uplink and downlink cloud processing.</p>"},{"location":"plugins/sigfox/#plugin-features","title":"Plugin Features","text":"<ul> <li>Automatic device and bucket provisioning for every new device that is included in the same Sigfox \"Device Type\".</li> <li>Store Sigfox device metadata: device location, signal quality, hardware serial, etc.</li> <li>Store device data automatically in data buckets so it can be easily used from the console.</li> <li>Custom uplink data processing with NodeJS, for both <code>payload_raw</code> or  <code>payload_fields</code> .</li> <li>Support for defining custom downlink callbacks in NodeJS, so it is possible to configure downlink data in an user-friendly format (JSON), and then convert it to <code>payload_raw</code> or <code>payload_fields</code>, as required by TTN network.</li> </ul>"},{"location":"plugins/sigfox/#sigfox-concepts","title":"Sigfox Concepts","text":"<p>For a better understanding of the following sections, here is described some basic Sigfox concepts:</p> <ul> <li>Device: It is a hardware device with an official Sigfox interface.</li> <li>Gateway: It is Sigfox infrastructure hardware interface that basically receives messages from multiple edge devices and pushes them to Sigfox server over IP communication. These gateways are exclusively property of Sigfox company.</li> <li>Uplink: It is a data flow which represents messages sent from a device to the sigfox cloud. There are two different uplink processes: unidirectional uplink (single data communication from the device to Sigfox network) and bidirectional uplink, that also allows to Sigfox system sending a Downlink to the device.</li> <li>Downlink: It is a data flow which represents messages sent from the Sigfox cloud to a device.</li> <li>Device Type: It is a concept that defines a group of devices of the same type, normally sending the same kind of data both in uplink and downlink).</li> </ul> <p>Info</p> <p>Learn how to configure Sigfox Callback to send data to Thinger.io platform here</p>"},{"location":"plugins/sigfox/#plugin-configuration","title":"Plugin Configuration","text":"<p>In this section it is described the different interfaces that can be used to configure the Sigfox plugin.</p>"},{"location":"plugins/sigfox/#applications","title":"Applications","text":"<p>Every Sigfox \"Device Type\" that is integrated over this plugin, should define a new profile in Thinger.io plugin, with the same identifier as defined in Sigfox Platform. Note that each Sigfox Device Type defined in this way will allow to customize the plugin behaviour for that kind of devices.</p> <p> </p> <p>It is possible to create as many Device Types profiles as required. To configure a new profile, just select the id from the Device Types dropdown, and then navigate to the other plugin sections.</p> <p>Warning</p> <p>Always create the Device Type with the same identifier as defined in Sigfox cloud.</p>"},{"location":"plugins/sigfox/#callback-config","title":"Callback Config","text":"<p>The uplink behaviour allows to configure how the plugin will react on new information received from Sigfox.</p> <p> </p> <p>The configurable parameters are the following:</p> <ul> <li>Auto provision resources: Enable or disable automatic resource provisioning while receiving messages for non created devices of the same Sigfox \"Device Type\".</li> <li>Device connection timeout: When creating a new device, establish the device connection timeout in minutes, so the platform can consider the device as disconnected after a fixed time without receiving a message.</li> <li>Device identifier prefix: When creating a new device, create it with a custom prefix + the original device id.</li> <li>Bucket identifier prefix: When creating a new data bucket associated to the device, create it with a custom prefix + the original device id.</li> <li>Update device location: Use the location provided in the gateways information to update thee current device location.</li> <li>Initialize downlink data: When creating a new device, initialize a custom downlink data, that can be modified and processed in further downlink requests.</li> </ul>"},{"location":"plugins/sigfox/#payload-processing","title":"Payload Processing","text":"<p>In this section it is possible to configure the payload processors that will transformate the raw data received from Sigfox payload in an uplink message, or the payload that is going to be sent  in a downlink message fron Thinger.io Platform to Sigfox Clous</p> <p>The interface provides a code editor for NodeJS, where it is possible to define the <code>uplink</code> and <code>downlink</code>processors. It is also possible to test the code by providing a sample input data both for <code>uplink</code> and <code>downlink</code>.</p> <p> </p> <p>In the following, there is information about the uplink and downlink methods.</p> UplinkDownlink <p>The uplink method will be called when a device sends a new message through the network. Depending on the configuration done in the Sigfox network, this function can receive two different inputs:</p> <ul> <li>Base64 String: If the Sigfox Device Type define a Custom payload format, this method will receive the raw payload encoded in base64. In this case, it will be necessary to write a function to transform this base64 data to a JSON object.</li> <li>JSON Object:The output of this method must be always a JSON object containing the information that is necessary to be used by the platform. In the following, there is an uplink method that converts base64 data into a JSON object with <code>temperature</code> and <code>humidity</code> parsed from the binary data.</li> </ul> <pre><code>/* convert a base64 payload to a JSON object that can be used\n  by Thinger.io */\n    module.exports.uplink = function(payload){\n    const buffer = Buffer.from(payload.data, 'hex');\n    payload.temperature = buffer.readInt16LE(0)/100.0;\n    payload.humidity = buffer.readInt16LE(2)/100.0;\n    return payload;\n};\n</code></pre> <p>Info</p> <p>The uplink method must always return a JSON object.</p> <p>The downlink method will be only called when the Sigfox device uplinks a bidirectional mesage to Sigfox Cloud. In this case, Thinger.io server will answer to the callback message that contains your custom Downlink payload in hexadecimal codification. Check out the next sections for more details.</p> <p>This function will receive different inputs depending on how the plugin is called over its REST API.</p> <ul> <li>JSON Object: If the downlink call is done for a Thinger.io device that defines a <code>downlink</code> property (that is automatically initialized if <code>Initialize Downlink Data</code> is configured in the plugin), this method will receive the JSON content of this property. It usually consists on a user-friendly device configuration that should be later encoded to binary in base64. </li> <li>JSON Object: If the plugin downlink request contains a JSON payload in the POST call, this function will receive this payload instead of the one configured in the device <code>downlink</code> property. </li> </ul> <p>The output of this method will be a Base64 String with the binary information that is going to be sent to Sigfox network.</p> <p>Warning</p> <p>When working with Downlink processes the<code>Initialize Downlink Data</code>parameter must be initialized with any data otherwise the processing of the downlink payload will fail</p> <p>Example of a downlink method converting a JSON device configuration into base64 as required by Sigfox:</p> <pre><code>/* convert a JSON object with the device configuration in a base64\n  string expected by Sigfox Cloud */\n\nmodule.exports.downlink = function(payload){\n\n    let bytes = [];\n    bytes[0] = payload.enabled ? 1 : 0;\n    bytes[1] = payload.frequency;\n    bytes[2] = payload.threshold;\n\n    return Buffer.from(bytes).toString('hex');\n};\n</code></pre> <p>Info</p> <p>Use the interface tester to see if your code is correctly procesing the payloads.</p>"},{"location":"plugins/sigfox/#sigfox-cloud-configuration","title":"Sigfox Cloud Configuration","text":"<p>After getting Thinger.io Plugin ready for receiving data, the next step is to configure the Sigfox Backend for pushing messages on it. This process has been simplified by the \"Sigfox Integration\" section of the plugin settings menu, that automatically builds the HTTP query and the Authorization token that needs to be included into Sigfox Callbacks Manager:</p> <p> </p> <p>Note that Sigfox Cloud provides three different API, depending on the kind of interaction that it's going to be created, Thinger.io Platform allows integrating with all of them: Uplink, Advanced Data and Downlink callback type. Each callback configuration can be created to work with a single device or over all the devices that belongs to the same Device Type.</p> <p>These are all the parameters that needs to be configured when creating a new callback:</p> <ul> <li>Callback Type: to define the callback behaviour.</li> <li>Custom Payload Config: (optional) to define how the device's message is going to be decoded.</li> <li>Url Pattern: place here the autogenerated Thinger.io URL pattern</li> <li>HTTP Method: POST for Uplink or GET for Downlink process.</li> <li>Authorization Header: must contain the autogenerated authorization to provide Sigfox Cloud the permission to send data to Thinger.io.</li> <li>Body: Configurable message payload with the specified content type.</li> </ul>"},{"location":"plugins/sigfox/#basic-uplink-integration","title":"Basic Uplink Integration","text":"<p>This callback configuration is the most common one, it just send devices data to Thinger.io in an unidirectional way to be stored, aggregate and show.</p> <p> </p>"},{"location":"plugins/sigfox/#uplink-with-computed-location-data-advanced","title":"Uplink with computed location (Data Advanced)","text":"<p>This callback configuration allows to retrieve additional information, such as geolocation, and infrastructure metadata like the computed over the different base stations which received the messages. However, working with this callback requires a delay of approximately 30s.</p> <p> </p>"},{"location":"plugins/sigfox/#uplink--downlink","title":"Uplink &amp; Downlink","text":"<p>Finally, selecting DATA/BIDIR Callback, it is possible to send uplink messages to configure Sigfox Cloud to send data to Thinger.io and waits for a downlink message that can be sent to the device in order to make any configuration or remote controlling processes. downlink payload processing</p> <p> </p> <p>The configuration of the Downlink message payload can be made in Thinger.io Platform,  using the Callback Config section of Sigfox Plugin or modifying each individual Downlink device property in the device dashboard:</p> <p> </p> <p>Tip</p> <p>It is mandatory to send the device in the callback payload. Other optional values are signal or location information extracted from Sigfox.</p> <pre><code>{\n    \"device\" : \"{device}\",\n    \"snr\" : {snr},\n    \"rssi\" : {rssi},\n    \"station\": \"{station}\",\n    \"latitude\": {lat},\n    \"longitude\": {lng},\n    \"temperature\" : {customData#temp},\n    \"humidity\" : {customData#hum}\n}\n</code></pre>"},{"location":"plugins/sigfox/#using-platform-features-with-sigfox-devices","title":"Using platform features with Sigfox devices","text":"<p>congratulations now you can retrieve data from all your Sigfox devices into Thinger.io platform and benefit from all its management, analysis and representation features to create amazing IoT projects in a very simple way. Here you have some basics about thinger.io capacities for Sigfox devices:</p>"},{"location":"plugins/sigfox/#checking-device-status","title":"Checking device status","text":"<p>As these devices are not real-time connected to the platform, it is hard to know if everything is running well in the long term, specially in large devices networks. But thanks to the timeout feature that is configurable using the \"device connection timeout\" of the plugin callback configuration menu, it is possible to know if a device is sending data in proper time frame or if otherwise it has stopped working  due to any problem by checking the \"device status\" that is available at its dashboard.</p> <p> </p> <p>It is also possible to check the status of a large amount of devices from the device list, but note that this page is not showing real-time data so it is necessary to refresh it to know the current status.</p>"},{"location":"plugins/sigfox/#storing-data-in-scalable-buckets","title":"Storing data in scalable buckets","text":"<p>One of the most used features of Thigner.io is the data buckets, which allows storing thousands of data in a scalable and easy way. The integration with sigfox through this new plugin allows to store data after the payload has been processed instead of storing it in raw or constraint format.</p> <p> </p> <p>Once stored in a data bucket, it is possible to work with these data points by downloading them in CSV and creating widgets to show data in customizable dashboards that can be easily shared with colleagues or customers. </p> <p> </p>"},{"location":"plugins/sigfox/#sending-data-to-third-parties-with-endpoints","title":"Sending Data to Third Parties with Endpoints","text":"<p>Thinger.io is part of a large ecosystem of technologies and platforms that enable you to get the most value from your data. That's why we have an Endpoint tool that allows you to forward data from any device to third party platforms and use other internet services to send emails, telegram messages, dump data on google spreadsheets, so almost any Internet service.</p>"},{"location":"plugins/sigfox/#combine-with-other-plugins","title":"Combine with other Plugins","text":"<p>at thinger.io we continue to work to extend the platform's integration capabilities with technologies that can help create more advanced IoT projects in the easiest way. We have other plugins such as NodeRED that allow working with IoT data in almost unlimited ways, such as creating alerts on the data, geofencing, reporting, etc.</p> <p> </p>"},{"location":"plugins/sigfox/#plugin-development-details","title":"Plugin Development Details","text":""},{"location":"plugins/sigfox/#uplink-data-flow","title":"Uplink Data Flow","text":"<p>In this section it is described how the uplink data flow works, from its source in the Sigfox network, to its final destination in Thinger.io.</p> <p> </p> <p>In the following subsections are described the elements shown in the figure.</p>"},{"location":"plugins/sigfox/#sigfox-uplink-callback","title":"Sigfox Uplink Callback","text":"<p>When Sigfox receives a message from any device, it automatically checks its configured integrations to forward them the information received. This plugin is integrated over HTTP, so, the Sigfox network will issue an HTTP request to the Thinger.io plugin on new messages.</p>"},{"location":"plugins/sigfox/#sigfox-plugin","title":"Sigfox Plugin","text":"<p>Thinger.io plugin receives data from Sigfox network in a JSON format. The callback includes several fields of information, such as <code>app_id</code>, <code>dev_id</code>, <code>donwlink_url</code>, <code>metadata</code>, or the actual payload information sent by LoRa devices on <code>payload_fields</code> or <code>payload_raw</code> fields, depending on the Payload formats configured in the Sigfox application.</p> <p>Here is an example of the raw information received by the plugin:</p> <pre><code>{\n    \"temperature\" : {customData#temp},\n    \"humidity\" : {customData#hum}\n    \"data\" : {data}\n}\n</code></pre> <p>Once this information is received by the plugin, it is processed in order to execute the following actions in Thinger.io:</p> <ol> <li>Auto provision new device and its associated data bucket if the device does not exists on the platform. It is based on the <code>dev_id</code> field.</li> <li>Call device callback that will actually push processed data to its associated data bucket, but could do any other action like forwarding data to other endpoints.</li> </ol>"},{"location":"plugins/sigfox/#uplink-processor","title":"Uplink Processor","text":"<p>This plugin allows to configure custom code for processing incoming data. The information sent by Sigfox devices is normally encoded in small binary payloads that cannot be directly used for representation, as they should not contain tags, JSON, ascii text, etc., in order to minimize transmission time. So, it is required to process the data sent by devices in some point of the cloud.</p> <p>This plugin also allows to create custom decoders if necessary. The advantage of using the Thinger.io payload processing (if necessary), is that it is using NodeJS runtime instead of plain Javascript, so it is possible to use NodeJS modules like Buffer, that simplifies the condig of the processing functions.</p> <p>Internaly, payload processors are precompiled after its configuration in the plugin, and executed with the payload data received from Sigfox. The output from this function (if it gets executed), is then transmitted to the next final step, which is the device callback.</p>"},{"location":"plugins/sigfox/#device-callback","title":"Device Callback","text":"<p>The last step of this plugin is to call the device callback in Thinger.io. This plugin auto provision new Sigfox devices as HTTP devices. HTTP devices inside Thinger.io are generic devices that can push data over REST API methods. Thinger.io will be responsable of taking input data and perform different configurable actions with it, like change the device state to connected/disconnected; write provided data to a configured data bucket; send this information to other services over an endpoint; store the provided information as a device property; or return data from one of the device properties.</p> <p>In this case, the plugin interacts with the platform over such REST interface, pushing data received from Sigfox, and processed by the custom uplink method. By default, the plugin initializes an HTTP device to write to a data bucket that is also automatically created. So, every message sent by a Sigfox device, will write finally write to a specific data bucket. As shown in the following picture:</p> <p> </p> <p>After the device callback is done, it will appear as a connected device, showing also its location if it was configured in the plugin options.</p>"},{"location":"plugins/sigfox/#vendor-integrations","title":"Vendor Integrations","text":""},{"location":"plugins/sigfox/#simple-hardware","title":"Simple Hardware","text":""},{"location":"plugins/sigfox/#downlinks","title":"Downlinks","text":"<p>SimpleHw device settings are stored in downlink registers as values and changing these values will change the settings and also device behavior. Register values can be changed via downlink over the air and up to 4 register values can be changed with one downlink - 4 bytes are register pointers from 0x00 to 0xFF and 4 bytes are register values from 0x00 to 0xFF for a total of 8 bytes (sigfox downlink limit). More details here.</p> <p>So, it is possible to update up to 0xFF registers from any device, at any moment by using downlinks. However, updating more than 4 registers involves several downlink requests where different registers at downloaded at each time.  With the Sigfox plugin extension it is possible to create the required flows to update any amount of registers by using the chaining feature from SimpleHw devices.</p> <p>The following code is a template with a set of features to correctly work with SimpleHw devices:</p> <ul> <li>Downlink sequence processing to affect how the device behaves: If the received register bytes are ascending from left to right, the device will automatically request another downlink.</li> <li>Acknowledgement from devices is processed to confirm that downlinks has been received correctly in the device.</li> <li>Selective register downlink synchronization based on register changes and confirmed registers.</li> </ul> <pre><code>/// state object to handle per-device registers and its acks\nlet state = {};\n\n// confirm downlink is received on the device state\nfunction confirmDownlink(device){\n    if(!state.hasOwnProperty(device)) return;\n\n    // get elements to ack\n    let toAck = state[device].toAck;\n    if(toAck===undefined) return;\n\n    // initialize acks if not already defined\n    if(state[device].ack===undefined) state[device].ack = {};\n\n    // update acknowledged\n    for(let key in toAck){\n        state[device].ack[key] = toAck[key];\n    }\n\n    // clear pending elements\n    delete state[device].toAck;\n}\n\n// selects the registers that are required to send\nfunction getRegistersToSend(device, target){\n    if(!state.hasOwnProperty(device)) return target;\n    let current = state[device].ack;\n    if(!current) return target;\n    let modified = {};\n    for (var key in target) {\n        if(!current.hasOwnProperty(key)){\n            modified[key] = target[key];\n        }else if(current[key]!==target[key]){\n            modified[key] = target[key];\n        }\n    }\n    return modified;\n}\n\n// convert JSON device downlink data to register configuration\nfunction getRegistersConfig(payload){\n    // should return an object with register number &amp; its value\n    let example = {\n        \"2c\" : 3,\n        \"aa\" : 217,\n        \"3f\" : 99,\n        \"0c\" : 1\n    }\n    return example;\n}\n\n// uplink method definition\nmodule.exports.uplink = function(payload, meta){\n    let deviceId = meta.device;\n\n    // acks to downlink\n    if(payload===\"15\"|| payload===\"16\"){\n        confirmDownlink(deviceId);\n        // return undefined so nothing is stored in bucket\n        return undefined;\n    }\n\n    // normal payload procesing here\n    // ...\n    return payload;\n};\n\n// downlink method definition\nmodule.exports.downlink = function(payload, meta){\n    let deviceId = meta.device;\n\n    // get device registers\n    let deviceRegisters = getRegistersConfig(payload);\n    let changedRegisters = getRegistersToSend(deviceId, deviceRegisters);\n\n    // compute registers to send and its order\n    let registers = Object.keys(changedRegisters);\n    if(registers.length&gt;4){\n        // ascending -&gt; device will request more\n        registers = registers.sort().slice(0,4);\n    }else{\n        // desdencing -&gt; no more downlinks\n        registers = registers.sort().reverse();\n    }\n\n    // init toAck state on device\n    if(!state.hasOwnProperty(deviceId)) state[deviceId] = {};\n    state[deviceId].toAck = {};\n\n    // generate downlink output\n    let bytes = [], written = 0;\n    registers.forEach(function(v) {\n      // write register number and its value\n      bytes[written++] = parseInt(v, 16);\n      bytes[written++] = changedRegisters[v];\n\n      // add register to pending ack\n      state[deviceId].toAck[v] = changedRegisters[v];\n    });\n\n    // convert buffer to hex for sigfox processing\n    return Buffer.from(bytes).toString('hex');\n};\n</code></pre>"},{"location":"plugins/sigfox/changelog/","title":"Changelog","text":""},{"location":"plugins/sigfox/changelog/#140---2023-07-10","title":"[1.4.0] - 2023-07-10","text":""},{"location":"plugins/sigfox/changelog/#added","title":"Added","text":"<ul> <li>Support for setting endpoint in autoprovisioned device callback</li> </ul>"},{"location":"plugins/sigfox/changelog/#security","title":"Security","text":"<ul> <li>Resolve all isues with dependencies with opened CVEs</li> </ul>"},{"location":"plugins/sigfox/changelog/#130---2023-03-29","title":"[1.3.0] - 2023-03-29","text":""},{"location":"plugins/sigfox/changelog/#added_1","title":"Added","text":"<ul> <li>Support for setting Project on auto-provisioned devices &amp; buckets</li> <li>Changelog</li> </ul>"},{"location":"plugins/sigfox/changelog/#fixed","title":"Fixed","text":"<ul> <li>Ensure provided Sigfox device type is available instead of using default settings</li> <li>Make sure Thinger server is running before starting service</li> </ul>"},{"location":"plugins/ttn-stack/","title":"The Things Stack","text":"<p>The Things Network is a LoRaWAN Network solution that simplifies the deployment of large IoT applications over a collaborative Internet of Things network that spans many countries around the world. From thinger.io we wanted to offer an improved integration to The Things Stack users by providing easy-to-configure tools for storing, analyzing, and showing device data in a simple way. This plugin allows retrieving The Things Stack webhook messages to enhance the integration with some interesting features such as:</p> <ul> <li>Uplink data payload processing</li> <li>Downlink data payload processing</li> <li>Automatic device and data buckets provisioning</li> </ul>"},{"location":"plugins/ttn-stack/#plugin-features","title":"Plugin Features","text":"<ul> <li> Automatic device and bucket provisioning for new devices is included in The Things Stack application. It is no required additional configuration to start working with The Things Stack data inside Thinger.io.</li> <li> Store device metadata based on The Things Stack information, like device location, signal quality, hardware serial, etc.</li> <li> Store device data automatically in data buckets so it can be easily used from the console.</li> <li> Provide support for defining custom uplink callbacks on Node.js  to process <code>payload_raw</code> or <code>payload_fields</code> provided by The Things Stack Integration.</li> <li> Provide support for defining custom downlink callbacks on Node.js, so it is possible to configure downlink data in a user-friendly format (JSON), and then convert it to <code>payload_raw</code> or <code>payload_fields</code>, as required by The Things Stack network.</li> </ul>"},{"location":"plugins/ttn-stack/#the-things-stack-concepts","title":"The Things Stack Concepts","text":"<p>For a better understanding of the following sections, here is described some basic The Things Stack concepts:</p> <ul> <li>Device: It is a hardware device with a LoRa interface.</li> <li>Gateway: It is a hardware device with both LoRa and Internet connectivity. It basically receives LoRa messages from multiple devices and pushes them to The Things Stack network over the Internet.</li> <li>Uplink: It is a data flow that represents messages sent from a device to The Things Stack network</li> <li>Downlink: It is a data flow that represents messages sent from The Things Stack network to a device.</li> <li>Application: It is a concept that defines a group of devices of the same type, normally sending the same kind of data both in uplink and downlink).</li> <li>Integration: It is a way of pushing device data outside The Things Stack network, i.e., sending messages to other platforms like Thinger.io.</li> </ul>"},{"location":"plugins/ttn-stack/#plugin-configuration","title":"Plugin Configuration","text":"<p>This section describes the different interfaces that can be used to configure The Things Stack plugin.</p>"},{"location":"plugins/ttn-stack/#integrating-the-things-stack-applications","title":"Integrating The Things Stack Applications","text":"<p>The first step to perform the integration is to create a new plugin configuration. It is possible to create multiple configuration profiles with custom behavior for each application deployed in The Things Stack. To create a new application profile, just type the application ID and press the green Add Application button. Note that the ID must be exactly the same identifier defined in The Things Stack application.</p> <p> </p> <p>The <code>Application Id</code> dropdown allows to select and configure a particular application profile, but if the \"default\" profile is selected, the configuration will be applied to all the applications integrated with the plugin.</p> <p>Warning</p> <p>Always create applications with the same application identifier as defined in The Things Stack.</p>"},{"location":"plugins/ttn-stack/#uplink-settings","title":"Uplink Settings","text":"<p>As shown in the image above, the parameters can be used to configure the plugin's behavior:</p> <ul> <li>Auto provision resources: Enable or disable automatic resource provisioning while receiving messages for non-created devices.</li> <li>Device Connection Timeout: When creating a new device, establish the device connection timeout in minutes, so the platform can consider the device as disconnected after a fixed time without receiving a message.</li> <li>Device Identifier Prefix: When creating a new device, create it with a custom prefix + the original device id.</li> <li>Bucket Identifier Prefix: When creating a new data bucket associated to the device, create it with a custom prefix + the original device id.</li> <li>Assign Asset Type: Associate the auto-provisioned device and bucket with a given Asset Type.</li> <li>Assign Asset Group: Associate the auto-provisioned device and bucket with a given Asset Group.</li> <li>Update device location: Use the location provided in the gateways information to update de current device location.</li> <li>Initialize Downlink Data: When creating a new device, initialize a custom downlink data, that can be modified and processed in further downlink requests.</li> </ul>"},{"location":"plugins/ttn-stack/#downlink-settings","title":"Downlink Settings","text":"<p>The Things Stack Downlink processes can be configured from Thinger.io in order to select the behavior in some parameters as shown below:</p> <p> </p> <ul> <li>Confirmed Downlink: Set to enabled if downlink messages must be confirmed by the device.</li> <li>Push To Downlink Queue: Enable to push downlink messages instead of replace previous ones.</li> <li>Downlink Priority: Specify the downlink priority.</li> </ul>"},{"location":"plugins/ttn-stack/#payload-processing","title":"Payload Processing","text":"<p>This tab is used to configure the payload data treatment in order to transform from binary payload received from The Things Stack webhook into user-friendly variables and the Downlink JSON into a binary buffer that will be transmitted to The Things Stack.</p> <p>The interface provides a code editor for Node.js scripts, where it is possible to define the codification / decodification processes and also provides a testing tool that allows to verify the behavior of both  <code>uplink</code> and <code>downlink</code> processes.</p> <p> </p> <p>The following sections provide additional information about how to configure the uplink and downlink methods.</p> UplinkDownlink <p>The uplink method will be called after a gateway sends a new message over The Things Stack network. Depending on the configuration done in The Things Stackapplication, this function will receive different inputs:</p> <ul> <li>Base64 String: If The Things Stack application defines <code>Custom Javascript Formatter</code> for the payload but does not provide a decoder function, this method will receive the raw payload encoded in base64. In this case, it will be necessary to write a function to transform this base64 data to a JSON object.</li> <li>JSON Object from Cayene LPP: If The Things Stack application defines a <code>Cayene LPP</code> payload formatter, The Things Stack will automatically convert the binary data to a JSON object that can be used directly by the platform. In this case, it is not necessary to define a custom uplink method unless you want to do some extra processing like incorporating calculated fields.</li> <li>JSON Object from Custom Decoder: If The Things Stack application defines <code>Custom Javascript Formatter</code>for the payload and provides a decoder function, this function will receive the output from The Things Stack function. In this case, creating a custom uplink method will be redundant, so create the function in The Things Stack, or in the plugin.</li> </ul> <p>The output of this method must be always a JSON object containing the information that is necessary to be used by the platform. In the following, there is an uplink method that converts base64 data into a JSON object with <code>temperature</code> and <code>humidity</code> parsed from the binary data.</p> <pre><code>/* convert a base64 payload to a JSON object that can be used \n  by Thinger.io */\nmodule.exports.uplink = function(payload){\n    const buffer = Buffer.from(payload, 'base64');\n    let processed = {};\n    processed.temperature = buffer.readInt16LE(0)/100.0;\n    processed.humidity = buffer.readInt16LE(2)/100.0;\n    return processed;\n};\n</code></pre> <p>Info</p> <p>The uplink method must always return a JSON object.</p> <p>The downlink method will be called before the plugin issues a downlink request to The Things Stack. To issue a downlink request to The Things Stack, this plugin must receive an HTTP POST call, indicating the Thinger.io device identifier, and it will automatically issue the request to the required The Things Stack endpoint and its specific protocol. Check out the next sections for more details.</p> <p>This function will receive different inputs depending on how the plugin is called over its REST API.</p> <ul> <li>JSON Object: If the downlink call is done for a Thinger.io device that defines a <code>downlink</code> property (that is automatically initialized if <code>Initialize Downlink Data</code> is configured in the plugin), this method will receive the JSON content of this property. It usually consists on a user-friendly device configuration that should be later encoded to binary in base64.</li> <li>JSON Object: If the plugin downlink request contains a JSON payload in the POST call, this function will receive this payload instead of the one configured in the device <code>downlink</code> property. </li> </ul> <p>The output of this method should be one of the following:</p> <ul> <li>Base64 String: With binary information that can be sent directly to The Things Stack network. It is required if your The Things Stack application is not defining a converter.</li> <li>JSON Object: If The Things Stack application provides a converter for your payloads, this method can return a JSON object that will be accesible in the converter method. In this case, creating a custom downlink method will be redundant, so create the funtion in The Things Stack, or in the plugin.</li> </ul> <p>Example of a downlink method converting a JSON device configuration into base64 as required by The Things Stack:</p> <pre><code>/* convert a JSON object with the device configuration in a base64\n  string expected by The Things Stack */\nmodule.exports.downlink = function(payload){\n    let bytes = [];\n    bytes[0] = payload.enabled ? 1 : 0;\n    bytes[1] = payload.frequency;\n    bytes[2] = payload.threshold;\n    return Buffer.from(bytes).toString('base64');\n};\n</code></pre> <p>Info</p> <p>The downlink method should return a base64 string if The Things Stack application does not define a converter.</p>"},{"location":"plugins/ttn-stack/#the-things-stack-console-configuration","title":"The Things Stack Console Configuration","text":""},{"location":"plugins/ttn-stack/#uplink-configuration","title":"Uplink Configuration","text":"<p>The last tab of the plugin configuration interface is called \"Webhook settings\", it has been created to help the developers to complete the integration in The Things Stack Console, by providing all the information required to set up the webhook profile. </p> <p> </p> <p>Info</p> <p>Note that the REST API does not define the application ID, this parameter will be checked by the plugin software to manage the payload according to the configuration.</p> <p>To create a new webhook integration follow the next steps in The Things Stack web console: 1. Select the Application to be integrated. 2. In the main menu open the \"Integrations\" section and click the \"Webhooks\" option. The webhooks list will be shown.</p> <p> </p> <p>3. Clicking the <code>+Add webhook</code> blue button in the right top corner of the interface allows choosing between different webhooks integration templates. Select Thinger.io template. Then, configure the webhook only requires filling the form with the information provided by Thinger.io \"webhook settings\" tab and selecting JSON webhook format.</p> <p> </p> <p>Info</p> <p>Note that the Authorization header must be set up using the access token including the \"Bearer\" command</p>"},{"location":"plugins/ttn-stack/#downlink-configuration","title":"Downlink Configuration","text":"<p>As part of the webhook template, the Download API key is automatically created, so no further configuration is required.</p>"},{"location":"plugins/ttn-stack/#executing-downlink-processes","title":"Executing Downlink Processes","text":"<p>Thinger.io's The Things Stack plugin has been prepared to automatically manage to send downlink messages to The Things Stack server, this system takes the data from the device downlink property, autogenerated during device provisioning, and inserts it as a response to the next HTTP request from the system. In this way, we can create device configuration and control processes just by modifying the value of this property by means of a Dashboard widget, Node-RED, or direct API integration.</p> <p>To create a new downlink process make sure to follow the next steps:</p> <ol> <li>Configure the plugin's downlink settings at Thinger.io</li> <li>Write a codification script if required using the plugin's \"downlink payload processing\"</li> <li>Modify the value of the property to launch the execution of the downlink process</li> </ol> <p>After this, the plugin will execute the payload processing and send it in response of the next The Things Stack API request to your server. It is possible to follow the trace of this communication by accessing the plugin's log and going to <code>Plugins&gt;Plugin profile&gt;Logs</code>.</p>"},{"location":"plugins/ttn-stack/#monitor-your-data","title":"Monitor Your Data","text":"<p>There are multiple ways to view the data sent by the device in Thinger.io.</p> <p>As long as the uplink messages are being sent by The Things Stack, the raw data will be available in the Thinger.io Data Bucket configured or auto-provisioned by the The Things Stack Plugin, without any further configuration.</p> <p> </p> <p>Nevertheless, it is recommended to create a Dashboard in Thinger.io to be able to view the data in a more comprehensive way.</p> <p> </p>"},{"location":"plugins/ttn-stack/changelog/","title":"Changelog","text":""},{"location":"plugins/ttn-stack/changelog/#104---2023-02-21","title":"1.0.4 - 2023-02-21","text":""},{"location":"plugins/ttn-stack/changelog/#fixed","title":"Fixed","text":"<ul> <li>Ensure provided device type is available instead of using default settings</li> </ul>"},{"location":"plugins/ttn-stack/changelog/#103---2023-02-20","title":"1.0.3 - 2023-02-20","text":""},{"location":"plugins/ttn-stack/changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Make sure Thinger server is running before starting service</li> </ul>"},{"location":"plugins/vscode/","title":"VS Code","text":"<p>The Thinger.io VS Code Plugin enables users to edit software files on the cloud using a fully-featured Integrated Development Environment (IDE) powered by Visual Studio Code (VS Code). This plugin also facilitates the coding of complete software and allows Over-The-Air (OTA) updates for microcontrollers directly from the cloud.</p>"},{"location":"plugins/vscode/#about-thingerio-and-vs-code-integration","title":"About Thinger.io and VS Code integration","text":"<p>Thinger.io cloud platform offers a VS Code plugin based on Code-Server. This integration allows you to seamlessly edit any file uploaded into Thinger.io using a powerful IDE. Additionally, you can conveniently update microcontrollers via OTA directly from the cloud.</p> <p>The plugin comes pre-installed with the complete setup of PlatformIO and the Thinger.io extension, making it effortless to get started with your projects.</p> <p> </p> <p>Furthermore, when accessing the File Storages in Thinger.io's web console, the platform detects the presence of VS Code and adds a convenient shortcut to open the storage inside the VS Code Plugin.</p> <p> </p> <p>Note</p> <p>Please note that the Thinger.io VS Code Plugin is available only for premium Thinger.io servers, from Medium subscription and upwards. You can check this link to create your own instance within minutes.</p>"},{"location":"plugins/vscode/#ota-support","title":"OTA Support","text":"<p>The plugin supports OTA updates for a wide range of devices. For the latest information on OTA programming, please refer to the OTA Programming page. To utilize OTA updates, it is necessary to initially upload an OTA compatible firmware to a device using a native IDE with options available for Arduino IDE or Visual Studio Code.</p>"},{"location":"plugins/vscode/changelog/","title":"Changelog","text":""},{"location":"plugins/vscode/changelog/#4141-2---2023-08-23","title":"4.14.1-2 - 2023-08-23","text":""},{"location":"plugins/vscode/changelog/#changed","title":"Changed","text":"<ul> <li>Marginally reduce the limit of memory to be able to run</li> </ul>"},{"location":"plugins/vscode/changelog/#4141-1---2023-07-26","title":"4.14.1-1 - 2023-07-26","text":""},{"location":"plugins/vscode/changelog/#added","title":"Added","text":"<ul> <li>Preinstallation of platformio-ide and thinger-io extension</li> <li>Default settings for Thinger.io extension configuration</li> </ul>"},{"location":"plugins/vscode/changelog/#changed_1","title":"Changed","text":"<ul> <li>Bumped to code-server version 4.14.1</li> </ul>"},{"location":"plugins/vscode/changelog/#4110-3---2023-03-31","title":"4.11.0-3 - 2023-03-31","text":"<ul> <li>Updated deprecated mod for code-server</li> </ul>"},{"location":"plugins/vscode/changelog/#4110-2---2023-03-29","title":"4.11.0-2 - 2023-03-29","text":"<ul> <li>Updated mount points for storages</li> </ul>"},{"location":"plugins/vscode/changelog/#4110-1---2023-03-28","title":"4.11.0-1 - 2023-03-28","text":"<ul> <li>Bumped code-server to version 4.11.0</li> </ul>"},{"location":"plugins/vscode/changelog/#460-1---2022-08-26","title":"4.6.0-1 - 2022-08-26","text":"<ul> <li>Downsized resource memory to 3.75GB</li> <li>Bumped to code-server version 4.6.0</li> </ul>"},{"location":"announcements/category/node-red/","title":"Node-RED","text":""},{"location":"announcements/category/rules/","title":"Rules","text":""},{"location":"announcements/category/sftpgo/","title":"SFTPGo","text":""},{"location":"announcements/category/data/","title":"Data","text":""},{"location":"announcements/category/sftp/","title":"SFTP","text":""},{"location":"announcements/category/ftp/","title":"FTP","text":""},{"location":"announcements/category/ftps/","title":"FTPS","text":""},{"location":"announcements/category/prometheus/","title":"Prometheus","text":""},{"location":"announcements/category/monitoring/","title":"Monitoring","text":""},{"location":"announcements/category/alerting/","title":"Alerting","text":""},{"location":"announcements/category/vs-code/","title":"VS Code","text":""},{"location":"announcements/page/2/","title":"Announcements","text":""}]}