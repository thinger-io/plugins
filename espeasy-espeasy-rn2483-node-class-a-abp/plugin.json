{
  "name": "espeasy_rn2483_node_class_a_abp",
  "version": "1.0.0",
  "description": "The ESPEasy RN2483 (Class A ABP) is a LoRaWAN® development board on Microchip RN2483 that supports Activation by Personalization (ABP). It supports over 100 sensors.",
  "author": "Thinger.io",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/thinger-io/plugins.git",
    "directory": "espeasy-espeasy-rn2483-node-class-a-abp"
  },
  "metadata": {
    "name": "ESPEASY-RN2483-NODE-CLASS-A-ABP",
    "description": "The ESPEasy RN2483 (Class A ABP) is a LoRaWAN® development board on Microchip RN2483 that supports Activation by Personalization (ABP). It supports over 100 sensors.",
    "image": "assets/espeasy-rn2483-package.png",
    "category": "devices",
    "vendor": "espeasy"
  },
  "resources": {
    "products": [
      {
        "description": "The ESPEasy RN2483 (Class A ABP) is a LoRaWAN® development board on Microchip RN2483 that supports Activation by Personalization (ABP). It supports over 100 sensors.",
        "enabled": true,
        "name": "ESPEASY-RN2483-NODE-CLASS-A-ABP",
        "product": "espeasy_rn2483_node_class_a_abp",
        "profile": {
          "api": {
            "downlink": {
              "enabled": true,
              "handle_connectivity": false,
              "request": {
                "data": {
                  "path": "/downlink",
                  "payload": "{\n    \"data\"    : \"{{payload.data=\"\"}}\",\n    \"port\"    :  {{payload.port=85}},\n    \"priority\":  {{payload.priority=3}},\n    \"confirmed\" :  {{payload.confirmed=false}},\n    \"uplink\"  :  {{property.uplink}} \n}",
                  "payload_function": "",
                  "payload_type": "",
                  "plugin": "{{property.uplink.source}}",
                  "target": "plugin_endpoint"
                }
              }
            },
            "uplink": {
              "device_id_resolver": "getId",
              "enabled": true,
              "handle_connectivity": true,
              "request": {
                "data": {
                  "payload": "{{payload}}",
                  "payload_function": "",
                  "payload_type": "source_payload",
                  "resource_stream": "uplink",
                  "target": "resource_stream"
                }
              }
            }
          },
          "autoprovisions": {
            "device_autoprovisioning": {
              "config": {
                "mode": "pattern",
                "pattern": "espeasy-rn2483.*"
              },
              "enabled": true
            }
          },
          "buckets": {
            "device_data": {
              "backend": "mongodb",
              "data": {
                "payload": "{{payload}}",
                "payload_function": "parseOrDecodeIncomingData",
                "payload_type": "source_payload",
                "resource": "uplink",
                "source": "resource",
                "update": "events"
              },
              "enabled": true,
              "retention": {
                "period": 3,
                "unit": "months"
              },
              "tags": []
            }
          },
          "code": {
            "code": "function decodeThingerUplink(thingerData) {\n    // 0. If data has already been decoded, we will return it\n    if (thingerData.decodedPayload) return thingerData.decodedPayload;\n    \n    // 1. Extract and Validate Input\n    // We need 'payload' (hex string) and 'fPort' (integer)\n    const hexPayload = thingerData.payload || \"\";\n    const port = thingerData.fPort || 1;\n\n    // 2. Convert Hex String to Byte Array\n    const bytes = [];\n    for (let i = 0; i < hexPayload.length; i += 2) {\n        bytes.push(parseInt(hexPayload.substr(i, 2), 16));\n    }\n\n    // 3. Dynamic Function Detection and Execution\n    \n    // CASE A: (The Things Stack v3)\n    if (typeof decodeUplink === 'function') {\n        try {\n            const input = {\n                bytes: bytes,\n                fPort: port\n            };\n            var result = decodeUplink(input);\n            \n            if (result.data) return result.data;\n\n            return result; \n        } catch (e) {\n            console.error(\"Error inside decodeUplink:\", e);\n            throw e;\n        }\n    }\n\n    // CASE B: Legacy TTN (v2)\n    else if (typeof Decoder === 'function') {\n        try {\n            return Decoder(bytes, port);\n        } catch (e) {\n            console.error(\"Error inside Decoder:\", e);\n            throw e;\n        }\n    }\n\n    // CASE C: No decoder found\n    else {\n        throw new Error(\"No compatible TTN decoder function (decodeUplink or Decoder) found in scope.\");\n    }\n}\n\n\n// TTN decoder\n// Decoder for device payload encoder \"PACKED\"\n// copy & paste to TTN Console V3 -> Applications -> Payload formatters -> Uplink -> Javascript\nfunction decodeUplink(input) {\n  var data = {};\n\n  var decoded = false;\n\n  if (input.bytes.length === 0) {\n    // Do nothing\n  } else {\n    if (input.fPort === 1) {\n      switch (input.bytes[0]) {\n        case 26:\n          // SysInfo\n          data = decode_plugin(input.fPort, input.bytes,\n            [header, uint24, uint24, int8, vcc, pct_8, uint8, uint8, uint8, uint8, uint24, uint16],\n            ['header', 'uptime', 'freeheap', 'rssi', 'vcc', 'load', 'ip1', 'ip2', 'ip3', 'ip4', 'web', 'freestack']);\n          decoded = true;\n          break;\n\n        case 82:\n          // GPS\n          if (input.bytes.length === 18) {\n            data = decode_plugin(input.fPort, input.bytes, [header, latLng, latLng, altitude, uint16_1e2, hdop, uint8, uint8],\n              ['header', 'latitude', 'longitude', 'altitude', 'speed', 'hdop', 'max_snr', 'sat_tracked']);\n            decoded = true;\n          } else if (input.bytes.length === 21) {\n            data = decode_plugin(input.fPort, input.bytes, [header, latLng, latLng, altitude, uint16_1e2, hdop, uint8, uint8, uint24_1e2],\n              ['header', 'latitude', 'longitude', 'altitude', 'speed', 'hdop', 'max_snr', 'sat_tracked', 'distance_total_km']);\n            decoded = true;\n          } else {\n            data = decode_plugin(input.fPort, input.bytes, [header, latLng, latLng, altitude, uint16_1e2, hdop, uint8, uint8, uint24_1e2, uint24_1e1],\n              ['header', 'latitude', 'longitude', 'altitude', 'speed', 'hdop', 'max_snr', 'sat_tracked', 'distance_total_km', 'distance_ref']);\n            decoded = true;\n          }\n          break;\n\n        case 85:\n          // AcuDC243\n          // FIXME TD-er: Same code as in P108, Make new type for this with 4 selectable variables\n          data = decode_plugin(input.fPort, input.bytes, [header, uint8, int32_1e4, uint8, int32_1e4, uint8, int32_1e4, uint8, int32_1e4],\n            ['header', 'unit1', 'val_1', 'unit2', 'val_2', 'unit3', 'val_3', 'unit4', 'val_4']);\n          decoded = true;\n          break;\n\n        case 102:\n          // PZEM004T v30\n          data = decode(bytes, [header, int16_1e1, int32_1e3, int32_1e1, int32_1e1, uint16_1e2, uint8_1e1],\n            ['header', 'voltage', 'current', 'power', 'energy', 'powerfactor', 'frequency']);\n          data.frequency += 40;\n          decoded = true;\n          break;\n\n        case 108:\n          // DDS238-x ZN\n          // FIXME TD-er: Same code as in P085, Make new type for this with 4 selectable variables\n          data = decode_plugin(input.fPort, input.bytes, [header, uint8, int32_1e4, uint8, int32_1e4, uint8, int32_1e4, uint8, int32_1e4],\n            ['header', 'unit1', 'val_1', 'unit2', 'val_2', 'unit3', 'val_3', 'unit4', 'val_4']);\n          decoded = true;\n          break;\n\n      }\n\n      if (!decoded) {\n        if (input.bytes.length === 9) {\n          data = decode_plugin(input.fPort, input.bytes, [header, int32_1e4], ['header', 'val_1']);\n          decoded = true;\n        }\n        // Dual value\n        if (input.bytes.length === 13) {\n          data = decode_plugin(input.fPort, input.bytes, [header, int32_1e4, int32_1e4], ['header', 'val_1', 'val_2']);\n          decoded = true;\n        }\n        // Triple value\n        if (input.bytes.length === 17) {\n          data = decode_plugin(input.fPort, input.bytes, [header, int32_1e4, int32_1e4, int32_1e4], ['header', 'val_1', 'val_2', 'val_3']);\n          decoded = true;\n        }\n        // Quad value\n        if (input.bytes.length === 21) {\n          data = decode_plugin(input.fPort, input.bytes, [header, int32_1e4, int32_1e4, int32_1e4, int32_1e4], ['header', 'val_1', 'val_2', 'val_3', 'val_4']);\n          decoded = true;\n        }\n      }\n    }\n\n  }\n  data.bytes = input.bytes; \n  data.port  = input.fPort;\n\n  return {\n    data: data,\n    warnings: [],\n    errors: []\n  };\n}\n\n\n// ----- contents of /src/decoder.js --------------------------------------------\n// https://github.com/thesolarnomad/lora-serialization/blob/master/src/decoder.js\n\nvar bytesToInt = function(bytes) {\n  var i = 0;\n  for (var x = 0; x < bytes.length; x++) {\n    i |= (bytes[x] << (x * 8));\n  }\n  return i;\n};\n\nvar version = function(bytes) {\n  if (bytes.length !== version.BYTES) {\n    throw new Error('version must have exactly 10 bytes');\n  }\n  return String.fromCharCode.apply(null, bytes).split('\\u0000')[0];\n};\nversion.BYTES = 10;\n\nvar uint8 = function(bytes) {\n  if (bytes.length !== uint8.BYTES) {\n    throw new Error('uint8 must have exactly 1 byte');\n  }\n  return bytesToInt(bytes);\n};\nuint8.BYTES = 1;\n\nvar uint16 = function(bytes) {\n  if (bytes.length !== uint16.BYTES) {\n    throw new Error('uint16 must have exactly 2 bytes');\n  }\n  return bytesToInt(bytes);\n};\nuint16.BYTES = 2;\n\nvar uint24 = function(bytes) {\n  if (bytes.length !== uint24.BYTES) {\n    throw new Error('uint24 must have exactly 3 bytes');\n  }\n  return bytesToInt(bytes);\n};\nuint24.BYTES = 3;\n\nvar uint32 = function(bytes) {\n  if (bytes.length !== uint32.BYTES) {\n    throw new Error('uint32 must have exactly 4 bytes');\n  }\n  return bytesToInt(bytes);\n};\nuint32.BYTES = 4;\n\nvar uint64 = function(bytes) {\n  if (bytes.length !== uint64.BYTES) {\n    throw new Error('uint64 must have exactly 8 bytes');\n  }\n  return bytesToInt(bytes);\n};\nuint64.BYTES = 8;\n\nvar int8 = function(bytes) {\n  if (bytes.length !== int8.BYTES) {\n    throw new Error('int8 must have exactly 1 byte');\n  }\n  var value = +(bytesToInt(bytes));\n  if (value > 127) {\n    value -= 256;\n  }\n  return value;\n};\nint8.BYTES = 1;\n\nvar int16 = function(bytes) {\n  if (bytes.length !== int16.BYTES) {\n    throw new Error('int16 must have exactly 2 bytes');\n  }\n  var value = +(bytesToInt(bytes));\n  if (value > 32767) {\n    value -= 65536;\n  }\n  return value;\n};\nint16.BYTES = 2;\n\n\nvar int24 = function(bytes) {\n  if (bytes.length !== int24.BYTES) {\n    throw new Error('int24 must have exactly 3 bytes');\n  }\n  var value = +(bytesToInt(bytes));\n  if (value > 8388608) {\n    value -= 16777216;\n  }\n  return value;\n};\nint24.BYTES = 3;\n\nvar int32 = function(bytes) {\n  if (bytes.length !== int32.BYTES) {\n    throw new Error('int32 must have exactly 4 bytes');\n  }\n  var value = +(bytesToInt(bytes));\n  if (value > 2147483647) {\n    value -= 4294967296;\n  }\n  return value;\n};\nint32.BYTES = 4;\n\n// Basic types with a factor in them.\nvar uint8_1e3 = function(bytes) {\n  return +(uint8(bytes) / 1e3).toFixed(3);\n};\nuint8_1e3.BYTES = uint8.BYTES;\nvar uint8_1e2 = function(bytes) {\n  return +(uint8(bytes) / 1e2).toFixed(2);\n};\nuint8_1e2.BYTES = uint8.BYTES;\nvar uint8_1e1 = function(bytes) {\n  return +(uint8(bytes) / 1e1).toFixed(1);\n};\nuint8_1e1.BYTES = uint8.BYTES;\n\nvar uint16_1e5 = function(bytes) {\n  return +(uint16(bytes) / 1e5).toFixed(5);\n};\nuint16_1e5.BYTES = uint16.BYTES;\nvar uint16_1e4 = function(bytes) {\n  return +(uint16(bytes) / 1e4).toFixed(4);\n};\nuint16_1e4.BYTES = uint16.BYTES;\nvar uint16_1e3 = function(bytes) {\n  return +(uint16(bytes) / 1e3).toFixed(3);\n};\nuint16_1e3.BYTES = uint16.BYTES;\nvar uint16_1e2 = function(bytes) {\n  return +(uint16(bytes) / 1e2).toFixed(2);\n};\nuint16_1e2.BYTES = uint16.BYTES;\nvar uint16_1e1 = function(bytes) {\n  return +(uint16(bytes) / 1e1).toFixed(1);\n};\nuint16_1e1.BYTES = uint16.BYTES;\n\nvar uint24_1e6 = function(bytes) {\n  return +(uint24(bytes) / 1e6).toFixed(6);\n};\nuint24_1e6.BYTES = uint24.BYTES;\nvar uint24_1e5 = function(bytes) {\n  return +(uint24(bytes) / 1e5).toFixed(5);\n};\nuint24_1e5.BYTES = uint24.BYTES;\nvar uint24_1e4 = function(bytes) {\n  return +(uint24(bytes) / 1e4).toFixed(4);\n};\nuint24_1e4.BYTES = uint24.BYTES;\nvar uint24_1e3 = function(bytes) {\n  return +(uint24(bytes) / 1e3).toFixed(3);\n};\nuint24_1e3.BYTES = uint24.BYTES;\nvar uint24_1e2 = function(bytes) {\n  return +(uint24(bytes) / 1e2).toFixed(2);\n};\nuint24_1e2.BYTES = uint24.BYTES;\nvar uint24_1e1 = function(bytes) {\n  return +(uint24(bytes) / 1e1).toFixed(1);\n};\nuint24_1e1.BYTES = uint24.BYTES;\n\nvar uint32_1e6 = function(bytes) {\n  return +(uint32(bytes) / 1e6).toFixed(6);\n};\nuint32_1e6.BYTES = uint32.BYTES;\nvar uint32_1e5 = function(bytes) {\n  return +(uint32(bytes) / 1e5).toFixed(5);\n};\nuint32_1e5.BYTES = uint32.BYTES;\nvar uint32_1e4 = function(bytes) {\n  return +(uint32(bytes) / 1e4).toFixed(4);\n};\nuint32_1e4.BYTES = uint32.BYTES;\nvar uint32_1e3 = function(bytes) {\n  return +(uint32(bytes) / 1e3).toFixed(3);\n};\nuint32_1e3.BYTES = uint32.BYTES;\nvar uint32_1e2 = function(bytes) {\n  return +(uint32(bytes) / 1e2).toFixed(2);\n};\nuint32_1e2.BYTES = uint32.BYTES;\nvar uint32_1e1 = function(bytes) {\n  return +(uint32(bytes) / 1e1).toFixed(1);\n};\nuint32_1e1.BYTES = uint32.BYTES;\n\nvar int8_1e3 = function(bytes) {\n  return +(int8(bytes) / 1e3).toFixed(3);\n};\nint8_1e3.BYTES = int8.BYTES;\nvar int8_1e2 = function(bytes) {\n  return +(int8(bytes) / 1e2).toFixed(2);\n};\nint8_1e2.BYTES = int8.BYTES;\nvar int8_1e1 = function(bytes) {\n  return +(int8(bytes) / 1e1).toFixed(1);\n};\nint8_1e1.BYTES = int8.BYTES;\n\nvar int16_1e5 = function(bytes) {\n  return +(int16(bytes) / 1e5).toFixed(5);\n};\nint16_1e5.BYTES = int16.BYTES;\nvar int16_1e4 = function(bytes) {\n  return +(int16(bytes) / 1e4).toFixed(4);\n};\nint16_1e4.BYTES = int16.BYTES;\nvar int16_1e3 = function(bytes) {\n  return +(int16(bytes) / 1e3).toFixed(3);\n};\nint16_1e3.BYTES = int16.BYTES;\nvar int16_1e2 = function(bytes) {\n  return +(int16(bytes) / 1e2).toFixed(2);\n};\nint16_1e2.BYTES = int16.BYTES;\nvar int16_1e1 = function(bytes) {\n  return +(int16(bytes) / 1e1).toFixed(1);\n};\nint16_1e1.BYTES = int16.BYTES;\n\nvar int24_1e6 = function(bytes) {\n  return +(int24(bytes) / 1e6).toFixed(6);\n};\nint24_1e6.BYTES = int24.BYTES;\nvar int24_1e5 = function(bytes) {\n  return +(int24(bytes) / 1e5).toFixed(5);\n};\nint24_1e5.BYTES = int24.BYTES;\nvar int24_1e4 = function(bytes) {\n  return +(int24(bytes) / 1e4).toFixed(4);\n};\nint24_1e4.BYTES = int24.BYTES;\nvar int24_1e3 = function(bytes) {\n  return +(int24(bytes) / 1e3).toFixed(3);\n};\nint24_1e3.BYTES = int24.BYTES;\nvar int24_1e2 = function(bytes) {\n  return +(int24(bytes) / 1e2).toFixed(2);\n};\nint24_1e2.BYTES = int24.BYTES;\nvar int24_1e1 = function(bytes) {\n  return +(int24(bytes) / 1e1).toFixed(1);\n};\nint24_1e1.BYTES = int24.BYTES;\n\nvar int32_1e6 = function(bytes) {\n  return +(int32(bytes) / 1e6).toFixed(6);\n};\nint32_1e6.BYTES = int32.BYTES;\nvar int32_1e5 = function(bytes) {\n  return +(int32(bytes) / 1e5).toFixed(5);\n};\nint32_1e5.BYTES = int32.BYTES;\nvar int32_1e4 = function(bytes) {\n  return +(int32(bytes) / 1e4).toFixed(4);\n};\nint32_1e4.BYTES = int32.BYTES;\nvar int32_1e3 = function(bytes) {\n  return +(int32(bytes) / 1e3).toFixed(3);\n};\nint32_1e3.BYTES = int32.BYTES;\nvar int32_1e2 = function(bytes) {\n  return +(int32(bytes) / 1e2).toFixed(2);\n};\nint32_1e2.BYTES = int32.BYTES;\nvar int32_1e1 = function(bytes) {\n  return +(int32(bytes) / 1e1).toFixed(1);\n};\nint32_1e1.BYTES = int32.BYTES;\n\n\nvar pluginid = function(bytes) {\n  return +(uint8(bytes));\n};\npluginid.BYTES = uint8.BYTES;\n\n\nvar latLng = function(bytes) {\n  // 2^23 / 180 = 46603...\n  return +(int24(bytes) / 46600);\n};\nlatLng.BYTES = int24.BYTES;\n\nvar hdop = function(bytes) {\n  return +(uint8(bytes) / 10).toFixed(2);\n};\nhdop.BYTES = uint8.BYTES;\n\nvar altitude = function(bytes) {\n  // Option to increase altitude resolution (also on encoder side)\n  return +(int16(bytes) / 4 - 1000).toFixed(1);\n};\naltitude.BYTES = int16.BYTES;\n\n// -1 .. 5.12V\nvar vcc = function(bytes) {\n  return +(uint8(bytes) / 41.83 - 1.0).toFixed(2);\n};\nvcc.BYTES = uint8.BYTES;\n\n// 0 .. 100%\nvar pct_8 = function(bytes) {\n  return +(uint8(bytes) / 2.56).toFixed(2);\n};\npct_8.BYTES = uint8.BYTES;\n\n\nvar bitmap1 = function(byte) {\n  if (byte.length !== bitmap1.BYTES) {\n    throw new Error('Bitmap must have exactly 1 byte');\n  }\n  var i = bytesToInt(byte);\n  var bm = ('00000000' + Number(i).toString(2)).substr(-8).split('').map(Number).map(Boolean);\n  return ['adr', 'screensaver', 'screen', 'countermode', 'blescan', 'antenna', 'filter', 'alarm']\n    .reduce(function(obj, pos, index) {\n      obj[pos] = +bm[index];\n      return obj;\n    }, {});\n};\nbitmap1.BYTES = 1;\n\nvar bitmap2 = function(byte) {\n  if (byte.length !== bitmap2.BYTES) {\n    throw new Error('Bitmap must have exactly 1 byte');\n  }\n  var i = bytesToInt(byte);\n  var bm = ('00000000' + Number(i).toString(2)).substr(-8).split('').map(Number).map(Boolean);\n  return ['gps', 'alarm', 'bme', 'counter', 'sensor1', 'sensor2', 'sensor3', 'battery']\n    .reduce(function(obj, pos, index) {\n      obj[pos] = +bm[index];\n      return obj;\n    }, {});\n};\nbitmap2.BYTES = 1;\n\nvar header = function(byte) {\n  if (byte.length !== header.BYTES) {\n    throw new Error('header must have exactly 5 bytes');\n  }\n  var values = [0, 0, 0, 0];\n  values[0] = bytesToInt(byte.slice(0, 1));\n  values[1] = bytesToInt(byte.slice(1, 3));\n  values[2] = bytesToInt(byte.slice(3, 4));\n  values[3] = bytesToInt(byte.slice(4, 5));\n\n  return ['plugin_id', 'IDX', 'samplesetcount', 'valuecount']\n    .reduce(function(obj, pos, index) {\n      obj[pos] = +values[index];\n      return obj;\n    }, {});\n};\nheader.BYTES = 5;\n\n\nvar decode = function(bytes, mask, names) {\n\n  var maskLength = mask.reduce(function(prev, cur) {\n    return prev + cur.BYTES;\n  }, 0);\n  if (bytes.length < maskLength) {\n    throw new Error('Mask length is ' + maskLength + ' whereas input is ' + bytes.length);\n  }\n\n  names = names || [];\n  var offset = 0;\n  return mask\n    .map(function(decodeFn) {\n      var current = bytes.slice(offset, offset += decodeFn.BYTES);\n      return decodeFn(current);\n    })\n    .reduce(function(prev, cur, idx) {\n      prev[names[idx] || idx] = cur;\n      return prev;\n    }, {});\n};\n\n\nvar decode_plugin = function(fPort, bytes, mask, names) {\n  return Converter(decode(bytes, mask, names), fPort);\n};\n\n\nfunction Converter(decoded, fPort) {\n\n  var converted = decoded;\n  var name = \"\";\n\n  if (fPort === 1) {\n    if ('header' in converted) {\n      switch (converted.header.plugin_id) {\n        case 1:\n          converted.name = \"Switch\";\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n\n        case 2:\n          converted.name = \"ADC\";\n          converted.analog = converted.val_1;\n          break;\n\n        case 3:\n          converted.name = \"Pulse\";\n          converted.count = converted.val_1;\n          converted.total = converted.val_2;\n          converted.time = converted.val_3;\n          break;\n\n        case 4:\n          converted.name = \"Dallas\";\n          // For compatibility reasons, also include temp.\n          converted.temp = converted.val_1;\n          converted.temp1 = converted.val_1;\n          converted.temp2 = converted.val_2;\n          converted.temp3 = converted.val_3;\n          converted.temp4 = converted.val_4;\n          break;\n\n        case 5:\n          converted.name = \"DHT\";\n          converted.temp = converted.val_1;\n          converted.hum = converted.val_2;\n          break;\n\n        case 6:\n          converted.name = \"BMP085\";\n          converted.temp = converted.val_1;\n          converted.pressure = converted.val_2;\n          break;\n\n        case 7:\n          converted.name = \"PCF8591\";\n          converted.analog = converted.val_1;\n          break;\n\n        case 8:\n          converted.name = \"RFID\"; {\n            // Not sure if it is present, since the sensor only has a single output value in ESPeasy.\n            var ulongvalue = converted.val_2 * 65536 + converted.val_1;\n            converted.tag = ulongvalue.toFixed(0);\n          }\n          break;\n\n        case 9:\n          converted.name = \"MCP\";\n          converted.state = converted.val_1;\n          break;\n\n        case 10:\n          converted.name = \"BH1750\";\n          converted.lux = converted.val_1;\n          break;\n\n        case 11:\n          converted.name = \"PME\";\n          converted.v1 = converted.val_1;\n          break;\n\n        case 12:\n          converted.name = \"LCD\";\n          // Should not output anything, echo the values just to be sure.\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n\n        case 13:\n          converted.name = \"HCSR04\";\n          converted.dist = converted.val_1;\n          break;\n\n        case 14:\n          converted.name = \"SI7021\";\n          converted.temp = converted.val_1;\n          converted.hum = converted.val_2;\n          break;\n\n        case 15:\n          converted.name = \"TSL2561\";\n          // Not sure if the last value is present.\n          converted.lux = converted.val_1;\n          converted.infrared = converted.val_2;\n          converted.broadband = converted.val_3;\n          converted.ratio = converted.val_4;\n          break;\n\n        case 16:\n          converted.name = \"IR_rx\";\n          converted.IR = converted.val_1;\n          break;\n\n        case 17:\n          converted.name = \"PN532\"; {\n            // Not sure if it is present, since the sensor only has a single output value in ESPeasy.\n            var ulongvalue = converted.val_2 * 65536 + converted.val_1;\n            converted.tag = ulongvalue.toFixed(0);\n          }\n          break;\n\n        case 18:\n          converted.name = \"GP2Y10\";\n          converted.dust = converted.val_1;\n          break;\n\n        case 19:\n          converted.name = \"PCF8574\";\n          converted.state = converted.val_1;\n          break;\n\n        case 20:\n          converted.name = \"Ser2Net\";\n          // Not sure if this one does output a useful value\n          converted.ser2net = converted.val_1;\n          break;\n\n        case 21:\n          converted.name = \"Level\";\n          converted.output = converted.val_1;\n          break;\n\n        case 22:\n          converted.name = \"PCA9685\";\n          // Should not output any value\n          /*\n          converted.v1  = converted.val_1;\n          converted.v2  = converted.val_2;\n          converted.v3  = converted.val_3;\n          converted.v4  = converted.val_4;\n          */\n          break;\n\n        case 23:\n          converted.name = \"OLED\";\n          // Should not output any value\n          /*\n          converted.v1  = converted.val_1;\n          converted.v2  = converted.val_2;\n          converted.v3  = converted.val_3;\n          converted.v4  = converted.val_4;\n          */\n          break;\n\n        case 24:\n          converted.name = \"MLX90614\";\n          converted.temp = converted.val_1;\n          break;\n\n        case 25:\n          converted.name = \"ADS1115\";\n          converted.analog = converted.val_1;\n          break;\n\n        case 26:\n          converted.name = \"Sysinfo\";\n          /*\n          converted.v1  = converted.val_1;\n          converted.v2  = converted.val_2;\n          converted.v3  = converted.val_3;\n          converted.v4  = converted.val_4;\n          */\n          converted.ip = [converted.ip1, converted.ip2, converted.ip3, converted.ip4].join('.');\n          break;\n\n        case 27:\n          converted.name = \"INA219\";\n          converted.volt = converted.val_1;\n          converted.current = converted.val_2;\n          converted.power = converted.val_3;\n          break;\n\n        case 28:\n          converted.name = \"BME280\";\n          converted.temp = converted.val_1;\n          converted.hum = converted.val_2;\n          converted.pressure = converted.val_3;\n          break;\n\n        case 29:\n          converted.name = \"MQTThelper\";\n          converted.output = converted.val_1;\n          break;\n\n        case 30:\n          converted.name = \"BMP280\";\n          converted.temp = converted.val_1;\n          converted.pressure = converted.val_2;\n          break;\n\n        case 31:\n          converted.name = \"SHT1X\";\n          converted.temp = converted.val_1;\n          converted.hum = converted.val_2;\n          break;\n\n        case 32:\n          converted.name = \"MS5611\";\n          converted.temp = converted.val_1;\n          converted.pressure = converted.val_2;\n          break;\n\n        case 33:\n          converted.name = \"Dummy\";\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n\n        case 34:\n          converted.name = \"DHT12\";\n          converted.temp = converted.val_1;\n          converted.hum = converted.val_2;\n          break;\n\n        case 35:\n          converted.name = \"IRTX\";\n          // Should not output anything\n          /*\n          converted.v1  = converted.val_1;\n          converted.v2  = converted.val_2;\n          converted.v3  = converted.val_3;\n          converted.v4  = converted.val_4;\n          */\n          break;\n\n        case 36:\n          converted.name = \"FrameOLED\";\n          // Should not output anything\n          /*\n          converted.v1  = converted.val_1;\n          converted.v2  = converted.val_2;\n          converted.v3  = converted.val_3;\n          converted.v4  = converted.val_4;\n          */\n          break;\n\n        case 37:\n          converted.name = \"MQTTImport\";\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n\n        case 38:\n          converted.name = \"NeoPixel\";\n          // Should not output anything\n          /*\n          converted.v1  = converted.val_1;\n          converted.v2  = converted.val_2;\n          converted.v3  = converted.val_3;\n          converted.v4  = converted.val_4;\n          */\n          break;\n\n        case 39:\n          converted.name = \"Thermocouple\";\n          converted.temp = converted.val_1;\n          break;\n\n        case 40:\n          converted.name = \"ID12\"; {\n            // Not sure if it is present, since the sensor only has a single output value in ESPeasy.\n            var ulongvalue = converted.val_2 * 65536 + converted.val_1;\n            converted.tag = ulongvalue.toFixed(0);\n          }\n          break;\n\n        case 41:\n          converted.name = \"NeoClock\";\n          // Should not output anything\n          /*\n          converted.v1  = converted.val_1;\n          converted.v2  = converted.val_2;\n          converted.v3  = converted.val_3;\n          converted.v4  = converted.val_4;\n          */\n          break;\n\n        case 42:\n          converted.name = \"Candle\";\n          converted.color = converted.val_1;\n          converted.brightness = converted.val_2;\n          converted.type = converted.val_3;\n          break;\n\n        case 43:\n          converted.name = \"ClkOutput\";\n          converted.output = converted.val_1;\n          break;\n\n        case 44:\n          converted.name = \"P1WifiGateway\";\n          converted.v1 = converted.val_1;\n          break;\n\n        case 45:\n          converted.name = \"MPU6050\";\n          // Not sure what to output here, since it uses \"send data option\"\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n\n        case 46:\n          converted.name = \"VentusW266\";\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          break;\n\n        case 47:\n          converted.name = \"i2c-soil-moisture-sensor\";\n          converted.temp = converted.val_1;\n          converted.moisture = converted.val_2;\n          converted.light = converted.val_3;\n          break;\n\n        case 48:\n          converted.name = \"Motorshield_v2\";\n          break;\n\n        case 49:\n          converted.name = \"MHZ19\";\n          converted.ppm = converted.val_1;\n          converted.temp = converted.val_2;\n          converted.U = converted.val_3;\n          break;\n\n        case 50:\n          converted.name = \"TCS34725\";\n          converted.R = converted.val_1;\n          converted.G = converted.val_2;\n          converted.B = converted.val_3;\n          converted.colortemp = converted.val_4;\n          break;\n\n        case 51:\n          converted.name = \"AM2320\";\n          converted.temp = converted.val_1;\n          converted.hum = converted.val_2;\n          break;\n\n        case 52:\n          converted.name = \"SenseAir\";\n          converted.ppm = converted.val_1;\n          converted.temp = converted.val_2;\n          break;\n\n        case 53:\n          converted.name = \"PMSx003\";\n          converted.pm1_0 = converted.val_1;\n          converted.pm2_5 = converted.val_2;\n          converted.pm10 = converted.val_3;\n          break;\n\n        case 54:\n          converted.name = \"DMX512\";\n          break;\n\n        case 55:\n          converted.name = \"Chiming\";\n          break;\n\n        case 56:\n          converted.name = \"SDS011-Dust\";\n          converted.pm2_5 = converted.val_1;\n          converted.pm10 = converted.val_2;\n          break;\n\n        case 57:\n          converted.name = \"HT16K33_LED\";\n          break;\n\n        case 58:\n          converted.name = \"HT16K33_KeyPad\";\n          converted.scancode = converted.val_1;\n          break;\n\n        case 59:\n          converted.name = \"Encoder\";\n          converted.counter = converted.val_1;\n          break;\n\n        case 60:\n          converted.name = \"MCP3221\";\n          converted.analog = converted.val_1;\n          break;\n\n        case 61:\n          converted.name = \"KeyPad\";\n          converted.scancode = converted.val_1;\n          break;\n\n        case 62:\n          converted.name = \"MPR121_KeyPad\";\n          converted.scancode = converted.val_1;\n          break;\n\n        case 63:\n          converted.name = \"TTP229_KeyPad\";\n          converted.scancode = converted.val_1;\n          break;\n\n        case 64:\n          converted.name = \"APDS9960\";\n          converted.gesture = converted.val_1;\n          converted.proximity = converted.val_2;\n          converted.light = converted.val_3;\n          break;\n\n        case 65:\n          converted.name = \"DRF0299_MP3\";\n          break;\n\n        case 66:\n          converted.name = \"VEML6040\";\n          converted.R = converted.val_1;\n          converted.G = converted.val_2;\n          converted.B = converted.val_3;\n          converted.W = converted.val_4;\n          break;\n\n        case 67:\n          converted.name = \"HX711_Load_Cell\";\n          converted.weight_A = converted.val_1;\n          converted.weight_B = converted.val_2;\n          break;\n\n        case 68:\n          converted.name = \"SHT3x\";\n          converted.temp = converted.val_1;\n          converted.hum = converted.val_2;\n          break;\n\n        case 69:\n          converted.name = \"LM75A\";\n          converted.temp = converted.val_1;\n          break;\n\n        case 70:\n          converted.name = \"NeoPixel_Clock\";\n          converted.enabled = converted.val_1;\n          converted.brightness = converted.val_2;\n          converted.marks = converted.val_3;\n          break;\n\n        case 71:\n          converted.name = \"Kamstrup401\";\n          converted.heat = converted.val_1;\n          converted.volume = converted.val_2;\n          break;\n\n        case 72:\n          converted.name = \"HDC1080\";\n          converted.temp = converted.val_1;\n          converted.hum = converted.val_2;\n          break;\n\n        case 73:\n          converted.name = \"7DGT\";\n          break;\n\n        case 74:\n          converted.name = \"TSL2591\";\n          converted.lux = converted.val_1;\n          converted.full = converted.val_2;\n          converted.visible = converted.val_3;\n          converted.infrared = converted.val_4;\n          break;\n\n        case 75:\n          converted.name = \"Nextion\";\n          converted.idx = converted.val_1;\n          converted.value = converted.val_2;\n          break;\n\n        case 76:\n          converted.name = \"HLW8012\";\n          converted.volt = converted.val_1;\n          converted.current = converted.val_2;\n          converted.power = converted.val_3;\n          converted.powerfactor = converted.val_4;\n          break;\n\n        case 77:\n          converted.name = \"CSE7766\";\n          converted.volt = converted.val_1;\n          converted.power = converted.val_2;\n          converted.current = converted.val_3;\n          converted.pulses = converted.val_4;\n          break;\n\n        case 78:\n          converted.name = \"Eastron\";\n          // Selectable outputs, so do not name them here\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n\n        case 79:\n          converted.name = \"Wemos_Motorshield\";\n          break;\n\n        case 80:\n          converted.name = \"DallasIButton\"; {\n            // Not sure if it is present, since the sensor only has a single output value in ESPeasy.\n            var ulongvalue = converted.val_2 * 65536 + converted.val_1;\n            converted.ibutton = ulongvalue.toFixed(0);\n          }\n          break;\n\n        case 81:\n          converted.name = \"Cron\";\n          converted.lastexec = converted.val_1;\n          converted.nextexec = converted.val_2;\n          break;\n\n        case 82:\n          converted.name = \"GPS\";\n          // GPS data is already decoded in packed_decoder.js\n          // HDOP is needed by TTN mapper to weigh the quality of the data.\n          // When using TTN mapper, make sure to output these values.\n          break;\n\n        case 83:\n          converted.name = \"SGP30\";\n          converted.tvoc = converted.val_1;\n          converted.eco2 = converted.val_2;\n          break;\n\n        case 84:\n          converted.name = \"VEML6070\";\n          converted.uv_raw = converted.val_1;\n          converted.uv_risk = converted.val_2;\n          converted.uv_power = converted.val_3;\n          break;\n\n        case 85:\n          converted.name = \"AcuDC243\";\n          // This plugin can output any value, so show string representation \n          // of the unit of measure\n          converted.unit1 = getAcuDC243Unit(converted.unit1);\n          converted.unit2 = getAcuDC243Unit(converted.unit2);\n          converted.unit3 = getAcuDC243Unit(converted.unit3);\n          converted.unit4 = getAcuDC243Unit(converted.unit4);\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n\n        case 86:\n          converted.name = \"Homie\";\n          // Can select a number of outputs\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n\n        case 87:\n          converted.name = \"SerialProxy\";\n          // This plugin currently outputs strings, so not useful for LoRa\n          /*\n          converted.v1  = converted.val_1;\n          converted.v2  = converted.val_2;\n          converted.v3  = converted.val_3;\n          converted.v4  = converted.val_4;\n          */\n          break;\n\n        case 89:\n          converted.name = \"Ping\";\n          converted.fails = converted.val_1;\n          break;\n\n        case 90:\n          converted.name = \"CCS811\";\n          converted.TVOC = converted.val_1;\n          converted.eCO2 = converted.val_2;\n          break;\n\n        case 91:\n          converted.name = \"SerSwitch\";\n          // Can select a number of outputs\n          converted.relay1 = converted.val_1;\n          converted.relay2 = converted.val_2;\n          converted.relay3 = converted.val_3;\n          converted.relay4 = converted.val_4;\n          break;\n\n        case 92:\n          converted.name = \"DLbus\";\n          // Can select a number of outputs\n          // TODO TD-er: Must add binary representation of all values\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n\n        case 93:\n          converted.name = \"MitsubishiHP\";\n          // Outputs string\n          // TODO TD-er: Must add binary representation of all values\n          converted.v1 = converted.val_1;\n          break;\n\n        case 94:\n          converted.name = \"CULreader\";\n          // Outputs string\n          // TODO TD-er: Must add binary representation of all values\n          converted.v1 = converted.val_1;\n          break;\n\n        case 97:\n          converted.name = \"ESP32Touch\";\n          converted.touch = converted.val_1;\n          break;\n\n        case 100:\n          converted.name = \"DS2423counter\";\n          // TODO TD-er: This is probably the worst possible value to send over a LoRa network, as packets may get lost.\n          converted.countdelta = converted.val_1;\n          break;\n\n        case 102:\n          converted.name = \"PZEM004T v30\";\n          break;\n\n        case 106:\n          converted.name = \"BME680\";\n          converted.temp = converted.val_1;\n          converted.hum = converted.val_2;\n          converted.pressure = converted.val_3;\n          converted.gas = converted.val_4;\n          break;\n\n        case 107:\n          converted.name = \"SI1145\";\n          converted.visible = converted.val_1;\n          converted.infra = converted.val_2;\n          converted.uv = converted.val_3;\n          break;\n\n        case 108:\n          converted.name = \"DDS238-x ZN\";\n          // This plugin can output any value, so show string representation \n          // of the unit of measure\n          converted.unit1 = getDDS238_xUnit(converted.unit1);\n          converted.unit2 = getDDS238_xUnit(converted.unit2);\n          converted.unit3 = getDDS238_xUnit(converted.unit3);\n          converted.unit4 = getDDS238_xUnit(converted.unit4);\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n\n        case 110:\n          converted.name = \"VL53L0X\";\n          converted.distance = converted.val_1;\n          break;\n\n        case 111:\n          converted.name = \"RC522 RFID\"; {\n            // Not sure if it is present, since the sensor only has a single output value in ESPeasy.\n            var ulongvalue = converted.val_2 * 65536 + converted.val_1;\n            converted.tag = ulongvalue.toFixed(0);\n          }\n          break;\n\n        case 113:\n          converted.name = \"VL53L1X\";\n          converted.distance = converted.val_1;\n          converted.ambient = converted.val_2;\n          break;\n\n        default:\n          converted.v1 = converted.val_1;\n          converted.v2 = converted.val_2;\n          converted.v3 = converted.val_3;\n          converted.v4 = converted.val_4;\n          break;\n      } // End Switch\n      delete converted[\"val_1\"];\n      delete converted[\"val_2\"];\n      delete converted[\"val_3\"];\n      delete converted[\"val_4\"];\n    }\n\n  }\n\n  return converted;\n};\n\nfunction getAcuDC243Unit(unit_id) {\n  switch (unit_id) {\n    case 0: // P085_QUERY_V       0\n      return \"V\";\n    case 1: // P085_QUERY_A       1\n      return \"A\";\n    case 2: // P085_QUERY_W       2\n      return \"W\";\n    case 3: // P085_QUERY_Wh_imp  3\n      return \"Wh imp\";\n    case 4: // P085_QUERY_Wh_exp  4\n      return \"Wh exp\";\n    case 5: // P085_QUERY_Wh_tot  5\n      return \"Wh total\";\n    case 6: // P085_QUERY_Wh_net  6\n      return \"Wh net\";\n    case 7: // P085_QUERY_h_tot   7\n      return \"hours tot\";\n    case 8: // P085_QUERY_h_load  8\n      return \"hours load\";\n  }\n  return \"unknown\" + unit_id;\n};\n\n\nfunction getDDS238_xUnit(unit_id) {\n  switch (unit_id) {\n    case 0: // P108_QUERY_V       0\n      return \"V\";\n    case 1: // P108_QUERY_A       1\n      return \"A\";\n    case 2: // P108_QUERY_W       2\n      return \"W\";\n    case 3: // P108_QUERY_VA      3\n      return \"VA\";\n    case 4: // P108_QUERY_PF      4\n      return \"cosphi\";\n    case 5: // P108_QUERY_F       5\n      return \"Hz\";\n    case 6: // P108_QUERY_Wh_imp  6\n      return \"Wh imp\";\n    case 7: // P108_QUERY_Wh_exp  7\n      return \"Wh exp\";\n    case 8: // P108_QUERY_Wh_tot  8\n      return \"Wh total\";\n  }\n  return \"unknown\" + unit_id;\n};\n\n\n\nif (typeof module === 'object' && typeof module.exports !== 'undefined') {\n  module.exports = {\n    uint8: uint8,\n    uint16: uint16,\n    uint24: uint24,\n    uint32: uint32,\n    int8: int8,\n    int16: int16,\n    int24: int24,\n    int32: int32,\n    uint8_1e3: uint8_1e3,\n    uint8_1e2: uint8_1e2,\n    uint8_1e1: uint8_1e1,\n    uint16_1e5: uint16_1e5,\n    uint16_1e4: uint16_1e4,\n    uint16_1e3: uint16_1e3,\n    uint16_1e2: uint16_1e2,\n    uint16_1e1: uint16_1e1,\n    uint24_1e6: uint24_1e6,\n    uint24_1e5: uint24_1e5,\n    uint24_1e4: uint24_1e4,\n    uint24_1e3: uint24_1e3,\n    uint24_1e2: uint24_1e2,\n    uint24_1e1: uint24_1e1,\n    uint32_1e6: uint32_1e6,\n    uint32_1e5: uint32_1e5,\n    uint32_1e4: uint32_1e4,\n    uint32_1e3: uint32_1e3,\n    uint32_1e2: uint32_1e2,\n    uint32_1e1: uint32_1e1,\n    int8_1e3: int8_1e3,\n    int8_1e2: int8_1e2,\n    int8_1e1: int8_1e1,\n    int16_1e5: int16_1e5,\n    int16_1e4: int16_1e4,\n    int16_1e3: int16_1e3,\n    int16_1e2: int16_1e2,\n    int16_1e1: int16_1e1,\n    int24_1e6: int24_1e6,\n    int24_1e5: int24_1e5,\n    int24_1e4: int24_1e4,\n    int24_1e3: int24_1e3,\n    int24_1e2: int24_1e2,\n    int24_1e1: int24_1e1,\n    int32_1e6: int32_1e6,\n    int32_1e5: int32_1e5,\n    int32_1e4: int32_1e4,\n    int32_1e3: int32_1e3,\n    int32_1e2: int32_1e2,\n    int32_1e1: int32_1e1,\n    pluginid: pluginid,\n    latLng: latLng,\n    hdop: hdop,\n    altitude: altitude,\n    vcc: vcc,\n    pct_8: pct_8,\n    bitmap1: bitmap1,\n    bitmap2: bitmap2,\n    header: header,\n    version: version,\n    decode: decode\n  };\n}",
            "environment": "javascript",
            "storage": "",
            "version": "1.0"
          },
          "properties": {
            "uplink": {
              "data": {
                "payload": "{{payload}}",
                "payload_function": "",
                "payload_type": "source_payload",
                "resource": "uplink",
                "source": "resource",
                "update": "events"
              },
              "default": {
                "source": "value"
              },
              "enabled": true
            }
          }
        },
        "_resources": {
          "properties": []
        }
      }
    ]
  }
}