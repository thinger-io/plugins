{
  "name": "pallidus_mr1",
  "version": "1.0.0",
  "description": "The MR1 Activity Sensor Wing allows mounting Panasonic WL series PIR sensors and connecting additional external sensors.",
  "author": "Thinger.io",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/thinger-io/plugins.git",
    "directory": "pallidus-mr1"
  },
  "metadata": {
    "name": "Pallidus MR1",
    "description": "The MR1 Activity Sensor Wing allows mounting Panasonic WL series PIR sensors and connecting additional external sensors.",
    "image": "assets/mr1.png",
    "category": "devices",
    "vendor": "pallidus"
  },
  "resources": {
    "products": [
      {
        "description": "The MR1 Activity Sensor Wing allows mounting Panasonic WL series PIR sensors and connecting additional external sensors.",
        "enabled": true,
        "name": "Pallidus MR1",
        "product": "pallidus_mr1",
        "profile": {
          "code": {
            "code": "function decodeThingerUplink(thingerData) {\n    // 0. If data has already been decoded, we will return it\n    if (thingerData.decodedPayload) return thingerData.decodedPayload;\n    \n    // 1. Extract and Validate Input\n    // We need 'payload' (hex string) and 'fPort' (integer)\n    const hexPayload = thingerData.payload || \"\";\n    const port = thingerData.fPort || 1;\n\n    // 2. Convert Hex String to Byte Array\n    const bytes = [];\n    for (let i = 0; i < hexPayload.length; i += 2) {\n        bytes.push(parseInt(hexPayload.substr(i, 2), 16));\n    }\n\n    // 3. Dynamic Function Detection and Execution\n    \n    // CASE A: (The Things Stack v3)\n    if (typeof decodeUplink === 'function') {\n        try {\n            const input = {\n                bytes: bytes,\n                fPort: port\n            };\n            var result = decodeUplink(input);\n            \n            if (result.data) return result.data;\n\n            return result; \n        } catch (e) {\n            console.error(\"Error inside decodeUplink:\", e);\n            throw e;\n        }\n    }\n\n    // CASE B: Legacy TTN (v2)\n    else if (typeof Decoder === 'function') {\n        try {\n            return Decoder(bytes, port);\n        } catch (e) {\n            console.error(\"Error inside Decoder:\", e);\n            throw e;\n        }\n    }\n\n    // CASE C: No decoder found\n    else {\n        throw new Error(\"No compatible TTN decoder function (decodeUplink or Decoder) found in scope.\");\n    }\n}\n\n\n// TTN decoder\n/*\n\nName:   codec-mr1.js\n\nFunction:\n    Decode port 0x02/0x03/0x04 format 0x26/0x36 messages for TTN console.\n\nCopyright and License:\n    See accompanying LICENSE file at https://github.com/mcci-catena/MCCI-Catena-4430/\n\nAuthor:\n    Dhinesh Kumar Pitchai, MCCI Corporation   August 2022\n\n*/\n\n// calculate dewpoint (degrees C) given temperature (C) and relative humidity (0..100)\n// from http://andrew.rsmas.miami.edu/bmcnoldy/Humidity.html\n// rearranged for efficiency and to deal sanely with very low (< 1%) RH\nfunction dewpoint(t, rh) {\n    var c1 = 243.04;\n    var c2 = 17.625;\n    var h = rh / 100;\n    if (h <= 0.01)\n        h = 0.01;\n    else if (h > 1.0)\n        h = 1.0;\n\n    var lnh = Math.log(h);\n    var tpc1 = t + c1;\n    var txc2 = t * c2;\n    var txc2_tpc1 = txc2 / tpc1;\n\n    var tdew = c1 * (lnh + txc2_tpc1) / (c2 - lnh - txc2_tpc1);\n    return tdew;\n}\n\n/*\n\nName:   CalculateHeatIndex()\n\nDescription:\n        Calculate the NWS heat index given dry-bulb T and RH\n\nDefinition:\n        function CalculateHeatIndex(t, rh) -> value or null\n\nDescription:\n        T is a Farentheit temperature in [76,120]; rh is a\n        relative humidity in [0,100]. The heat index is computed\n        and returned; or an error is returned.  For consistency with\n        the other temperature, despite the heat index being defined\n        in Farenheit, we return in Celsius.\n\nReturns:\n        number => heat index in Farenheit.\n        null => error.\n\nReferences:\n        https://github.com/mcci-catena/heat-index/\n        https://www.wpc.ncep.noaa.gov/html/heatindex_equation.shtml\n\n        Results was checked against the full chart at iweathernet.com:\n        https://www.iweathernet.com/wxnetcms/wp-content/uploads/2015/07/heat-index-chart-relative-humidity-2.png\n\n        The MCCI-Catena heat-index site has a test js script to generate CSV to\n        match the chart, a spreadsheet that recreates the chart, and a\n        spreadsheet that compares results.\n\n*/\n\nfunction CalculateHeatIndex(t, rh) {\n    var tRounded = Math.floor(t + 0.5);\n\n    // return null outside the specified range of input parameters\n    if (tRounded < 76 || tRounded > 126)\n        return null;\n    if (rh < 0 || rh > 100)\n        return null;\n\n    // according to the NWS, we try this first, and use it if we can\n    var tHeatEasy = 0.5 * (t + 61.0 + ((t - 68.0) * 1.2) + (rh * 0.094));\n\n    // The NWS says we use tHeatEasy if (tHeatHeasy + t)/2 < 80.0\n    // This is the same computation:\n    if ((tHeatEasy + t) < 160.0)\n            return (tHeatEasy - 32) * 5 / 9;\n\n    // need to use the hard form, and possibly adjust.\n    var t2 = t * t;         // t squared\n    var rh2 = rh * rh;      // rh squared\n    var tResult =\n        -42.379 +\n        (2.04901523 * t) +\n        (10.14333127 * rh) +\n        (-0.22475541 * t * rh) +\n        (-0.00683783 * t2) +\n        (-0.05481717 * rh2) +\n        (0.00122874 * t2 * rh) +\n        (0.00085282 * t * rh2) +\n        (-0.00000199 * t2 * rh2);\n\n    // these adjustments come from the NWA page, and are needed to\n    // match the reference table.\n    var tAdjust;\n    if (rh < 13.0 && 80.0 <= t && t <= 112.0)\n        tAdjust = -((13.0 - rh) / 4.0) * Math.sqrt((17.0 - Math.abs(t - 95.0)) / 17.0);\n    else if (rh > 85.0 && 80.0 <= t && t <= 87.0)\n        tAdjust = ((rh - 85.0) / 10.0) * ((87.0 - t) / 5.0);\n    else\n        tAdjust = 0;\n\n    // apply the adjustment\n    tResult += tAdjust;\n\n    // finally, the reference tables have no data above 183 (rounded),\n    // so filter out answers that we have no way to vouch for.\n    if (tResult >= 183.5)\n        return null;\n    else\n        return (tResult - 32) * 5 / 9;\n}\n\nfunction DecodeU16(Parse) {\n    var i = Parse.i;\n    var bytes = Parse.bytes;\n    var result = (bytes[i] << 8) + bytes[i + 1];\n    Parse.i = i + 2;\n    return result;\n}\n\nfunction DecodeUflt16(Parse) {\n    var rawUflt16 = DecodeU16(Parse);\n    var exp1 = rawUflt16 >> 12;\n    var mant1 = (rawUflt16 & 0xFFF) / 4096.0;\n    var f_unscaled = mant1 * Math.pow(2, exp1 - 15);\n    return f_unscaled;\n}\n\nfunction DecodeSflt16(Parse)\n    {\n    var rawSflt16 = DecodeU16(Parse);\n    // rawSflt16 is the 2-byte number decoded from wherever;\n    // it's in range 0..0xFFFF\n    // bit 15 is the sign bit\n    // bits 14..11 are the exponent\n    // bits 10..0 are the the mantissa. Unlike IEEE format,\n    // the msb is explicit; this means that numbers\n    // might not be normalized, but makes coding for\n    // underflow easier.\n    // As with IEEE format, negative zero is possible, so\n    // we special-case that in hopes that JavaScript will\n    // also cooperate.\n    //\n    // The result is a number in the open interval (-1.0, 1.0);\n    //\n\n    // throw away high bits for repeatability.\n    rawSflt16 &= 0xFFFF;\n\n    // special case minus zero:\n    if (rawSflt16 === 0x8000)\n        return -0.0;\n\n    // extract the sign.\n    var sSign = ((rawSflt16 & 0x8000) !== 0) ? -1 : 1;\n\n    // extract the exponent\n    var exp1 = (rawSflt16 >> 11) & 0xF;\n\n    // extract the \"mantissa\" (the fractional part)\n    var mant1 = (rawSflt16 & 0x7FF) / 2048.0;\n\n    // convert back to a floating point number. We hope\n    // that Math.pow(2, k) is handled efficiently by\n    // the JS interpreter! If this is time critical code,\n    // you can replace by a suitable shift and divide.\n    var f_unscaled = sSign * mant1 * Math.pow(2, exp1 - 15);\n\n    return f_unscaled;\n    }\n\n\nfunction DecodeLight(Parse) {\n    return DecodeUflt16(Parse);\n}\n\nfunction DecodeActivity(Parse) {\n    return DecodeSflt16(Parse);\n}\n\nfunction DecodeI16(Parse) {\n    var i = Parse.i;\n    var bytes = Parse.bytes;\n    var result = (bytes[i] << 8) + bytes[i + 1];\n    Parse.i = i + 2;\n\n    // interpret uint16 as an int16 instead.\n    if (result & 0x8000)\n        result += -0x10000;\n\n    return result;\n}\n\nfunction DecodeU24(Parse) {\n    var i = Parse.i;\n    var bytes = Parse.bytes;\n\n    var result = (bytes[i] << 16) + (bytes[i + 1] << 8) + bytes[i + 2];\n    Parse.i = i + 3;\n\n    return result;\n}\n\nfunction DecodeSflt24(Parse)\n    {\n    var rawSflt24 = DecodeU24(Parse);\n    // rawSflt24 is the 3-byte number decoded from wherever;\n    // it's in range 0..0xFFFFFF\n    // bit 23 is the sign bit\n    // bits 22..16 are the exponent\n    // bits 15..0 are the the mantissa. Unlike IEEE format,\n    // the msb is explicit; this means that numbers\n    // might not be normalized, but makes coding for\n    // underflow easier.\n    // As with IEEE format, negative zero is possible, so\n    // we special-case that in hopes that JavaScript will\n    // also cooperate.\n\n    // extract sign, exponent, mantissa\n    var bSign     = (rawSflt24 & 0x800000) ? true : false;\n    var uExp      = (rawSflt24 & 0x7F0000) >> 16;\n    var uMantissa = (rawSflt24 & 0x00FFFF);\n\n    // if non-numeric, return appropriate result.\n    if (uExp === 0x7F) {\n        if (uMantissa === 0)\n            return bSign ? Number.NEGATIVE_INFINITY\n                    : Number.POSITIVE_INFINITY;\n        else\n            return Number.NaN;\n    // else unless denormal, set the 1.0 bit\n    } else if (uExp !== 0) {\n        uMantissa += 0x010000;\n    } else { // denormal: exponent is the minimum\n        uExp = 1;\n    }\n\n    // make a floating mantissa in [0,2); usually [1,2), but\n    // sometimes (0,1) for denormals, and exactly zero for zero.\n    var mantissa = uMantissa / 0x010000;\n\n    // apply the exponent.\n    mantissa = Math.pow(2, uExp - 63) * mantissa;\n\n    // apply sign and return result.\n    return bSign ? -mantissa : mantissa;\n    }\n\nfunction DecodeLux(Parse) {\n    return DecodeSflt24(Parse);\n}\n\nfunction DecodeI32(Parse) {\n    var i = Parse.i;\n    var bytes = Parse.bytes;\n\n    var result = (bytes[i + 0] << 24)+ (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3];\n    Parse.i = i + 4;\n\n    // interpret uint16 as an int16 instead.\n    if (result & 0x80000000)\n        result += -0x100000000;\n\n    return result;\n}\n\nfunction DecodeU32(Parse) {\n    var i = Parse.i;\n    var bytes = Parse.bytes;\n\n    var result = (bytes[i + 0] << 24)+ (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3];\n    Parse.i = i + 4;\n\n    return result;\n}\n\nfunction RemainingBytes(Parse) {\n    var i = Parse.i;\n    var nBytes = Parse.bytes.length;\n\n    if (i < nBytes)\n        return (nBytes - i);\n    else\n        return 0;\n}\n\nfunction DecodeV(Parse) {\n    return DecodeI16(Parse) / 4096.0;\n}\n\nfunction DecodeDownlinkResponse(bytes, port) {\n    // Decode an uplink message from a buffer\n    // (array) of bytes to an object of fields.\n    var decoded = {};\n\n    // an object to help us parse.\n    var Parse = {};\n    Parse.bytes = bytes;\n    // i is used as the index into the message. Start with the flag byte.\n    Parse.i = 0;\n\n    if (port === 1)\n        {\n        // SW version and HW details.\n        decoded.ResponseType = \"Set Uplink Interval\";\n        // fetch the bitmap.\n        var response = bytes[Parse.i++];\n        if (response === 0)\n            decoded.response = \"Success\";\n        else if (response === 1)\n            decoded.response = \"Invalid Length\";\n        else if (response === 2)\n            decoded.response = \"Failure\";\n        else if (response === 3)\n            decoded.response = \"Invalid Range\";\n        }\n\n    else if (port === 2)\n        {\n        // SW version and HW details.\n        decoded.ResponseType = \"SCD30 CO2 Calibration\";\n        // fetch the bitmap.\n        var response = bytes[Parse.i++];\n        if (response === 0)\n            decoded.response = \"Success\";\n        else if (response === 1)\n            decoded.response = \"Invalid Length\";\n        else if (response === 2)\n            decoded.response = \"Failure\";\n        else if (response === 3)\n            decoded.response = \"Invalid Range\";\n        else if (response === 4)\n            decoded.response = \"Sensor Not Connected\";\n        }\n\n    else if (port === 3)\n        {\n        // fetch the bitmap.\n        var command = bytes[Parse.i++];\n\n        if (command === 0x02) {\n            // Reset do not send a reply back.\n        }\n\n        else if (command === 0x03) {\n            // SW version and HW details.\n            decoded.ResponseType = \"Device Version\";\n\n            var responseError = bytes[Parse.i++];\n            if (responseError === 0)\n                decoded.ResponseError = \"Success\";\n            else if (responseError === 1)\n                decoded.ResponseError = \"Invalid Length\";\n            else if (responseError === 2)\n                decoded.ResponseError = \"Failure\";\n\n            var vMajor = bytes[Parse.i++];\n            var vMinor = bytes[Parse.i++];\n            var vPatch = bytes[Parse.i++];\n            var vLocal = bytes[Parse.i++];\n            decoded.AppVersion = \"V\" + vMajor + \".\" + vMinor + \".\" + vPatch + \".\" + vLocal;\n\n            var Model = DecodeU16(Parse);\n            var Rev = bytes[Parse.i++];\n            if (!(Model === 0))\n                {\n                decoded.Model = Model;\n                if (Rev === 0)\n                    decoded.Rev = \"A\";\n                else if (Rev === 1)\n                    decoded.Rev = \"B\";\n                else if (Rev === 2)\n                    decoded.Rev = \"C\";\n                else if (Rev === 3)\n                    decoded.Rev = \"D\";\n                else if (Rev === 4)\n                    decoded.Rev = \"E\";\n                else if (Rev === 5)\n                    decoded.Rev = \"F\";\n                else if (Rev === 6)\n                    decoded.Rev = \"G\";\n                }\n            else if (Model === 0)\n                {\n                decoded.Model = 4610;\n                decoded.Rev = \"Not Found\";\n                }\n            }\n\n        else if (command === 0x04) {\n            // Reset/Set AppEUI.\n            decoded.ResponseType = \"AppEUI Set\";\n\n            var responseError = bytes[Parse.i++];\n            if (responseError === 0)\n                decoded.ResponseError = \"Success\";\n            else if (responseError === 1)\n                decoded.ResponseError = \"Invalid Length\";\n            else if (responseError === 2)\n                decoded.ResponseError = \"Failure\";\n        }\n\n        else if (command === 0x05) {\n            // Reset/Set AppKey.\n            decoded.ResponseType = \"AppKey set\";\n\n            var responseError = bytes[Parse.i++];\n            if (responseError === 0)\n                decoded.ResponseError = \"Success\";\n            else if (responseError === 1)\n                decoded.ResponseError = \"Invalid Length\";\n            else if (responseError === 2)\n                decoded.ResponseError = \"Failure\";\n        }\n\n        else if (command === 0x06) {\n            // Rejoin the network.\n            decoded.ResponseType = \"Rejoin\";\n\n            var responseError = bytes[Parse.i++];\n            if (responseError === 0)\n                decoded.ResponseError = \"Success\";\n            else if (responseError === 1)\n                decoded.ResponseError = \"Invalid Length\";\n            else if (responseError === 2)\n                decoded.ResponseError = \"Failure\";\n        }\n\n        else if (command === 0x07) {\n            // Uplink Interval for sensor data.\n            decoded.ResponseType = \"Uplink Interval\";\n\n            var responseError = bytes[Parse.i++];\n            if (responseError === 0)\n                decoded.ResponseError = \"Success\";\n            else if (responseError === 1)\n                decoded.ResponseError = \"Invalid Length\";\n            else if (responseError === 2)\n                decoded.ResponseError = \"Failure\";\n\n            decoded.UplinkInterval = DecodeU32(Parse);\n        }\n        else\n            return null;\n    }\n\n    return decoded;\n}\n\nfunction Decoder(bytes, port) {\n    // Decode an uplink message from a buffer\n    // (array) of bytes to an object of fields.\n    var decoded = {};\n\n    if (! (port === 1) && ! (port === 2) && ! (port === 3) && ! (port === 4))\n        return null;\n\n    var uFormat = bytes[0];\n    if (! (uFormat === 0x26) && ! (uFormat === 0x36) && ((port === 1) || (port === 2) || (port === 3)))\n        {\n        decoded = DecodeDownlinkResponse(bytes, port);\n        return decoded;\n        }\n    else if (! (uFormat === 0x26) && ! (uFormat === 0x36) && ! ((port === 1) || (port === 2) || (port === 3)))\n        return null;\n\n    // an object to help us parse.\n    var Parse = {};\n    Parse.bytes = bytes;\n    // i is used as the index into the message. Start with the time.\n    Parse.i = 1;\n\n    // fetch time; convert to database time (which is UTC-like ignoring leap seconds)\n    decoded.time = new Date((DecodeU32(Parse) + /* gps epoch to posix */ 315964800 - /* leap seconds */ 17) * 1000).toISOString();\n\n    // fetch the bitmap.\n    var flags = bytes[Parse.i++];\n\n    if (flags & 0x1) {\n        decoded.Vbat = DecodeV(Parse);\n    }\n\n    if (flags & 0x2) {\n        var vMajor = bytes[Parse.i++];\n        var vMinor = bytes[Parse.i++];\n        var vPatch = bytes[Parse.i++];\n        var vLocal = bytes[Parse.i++];\n\n        decoded.version = vMajor + \".\" + vMinor + \".\" + vPatch + \".\" + vLocal;\n    }\n\n    if (flags & 0x4) {\n        // we have CO2 ppm.\n        decoded.co2 = DecodeUflt16(Parse) * 40000;\n    }\n\n    if (flags & 0x8) {\n        var iBoot = bytes[Parse.i++];\n        decoded.boot = iBoot;\n    }\n\n    if (flags & 0x10) {\n        if (uFormat === 0x26) {\n            // we have temp, pressure, RH\n            decoded.tempC = DecodeI16(Parse) / 256;\n            decoded.p = DecodeU16(Parse) * 4 / 100.0;\n            decoded.rh = DecodeU16(Parse) * 100 / 65535.0;\n            decoded.tDewC = dewpoint(decoded.tempC, decoded.rh);\n            var tHeat = CalculateHeatIndex(decoded.tempC * 1.8 + 32, decoded.rh);\n            if (tHeat !== null)\n                decoded.tHeatIndexC = tHeat;\n            }\n        else if (uFormat === 0x36) {\n            // we have temp, pressure, RH\n            decoded.tempC = DecodeI16(Parse) / 256;\n            decoded.rh = DecodeU16(Parse) * 100 / 65535.0;\n            decoded.tDewC = dewpoint(decoded.tempC, decoded.rh);\n            var tHeat = CalculateHeatIndex(decoded.tempC * 1.8 + 32, decoded.rh);\n            if (tHeat !== null)\n                decoded.tHeatIndexC = tHeat;\n            }\n    }\n\n    if (flags & 0x20) {\n        if (uFormat === 0x26) {\n            // we have light\n            decoded.irradiance = {};\n            decoded.irradiance.White = DecodeLight(Parse) * Math.pow(2.0, 24);\n        }\n        else if (uFormat === 0x36) {\n            // we have light\n            decoded.lux = DecodeLux(Parse);\n        }\n    }\n\n    if (flags & 0x40) {\n        // we have gpio counts\n        decoded.pellets = [];\n        for (var i = 0; i < 2; ++i) {\n            decoded.pellets[i] = {};\n            decoded.pellets[i].Total = DecodeU16(Parse);\n            decoded.pellets[i].Delta = bytes[Parse.i++];\n        }\n    }\n\n    if (flags & 0x80) {\n        // we have Activity\n        decoded.activity = [];\n        var i = 0;\n        while (RemainingBytes(Parse) >= 2) {\n            decoded.activity[i] = DecodeActivity(Parse);\n            ++i;\n        }\n    }\n\n    if (port === 3)\n        decoded.NwTime = \"set\";\n    \n    return decoded;\n}\n\n// TTN V3 decoder\nfunction decodeUplink(tInput) {\n    var decoded = Decoder(tInput.bytes, tInput.fPort);\n    var result = {};\n    result.data = decoded;\n    return result;\n}\n",
            "environment": "javascript",
            "storage": "",
            "version": "1.0"
          }
        },
        "_resources": {
          "properties": []
        }
      }
    ]
  }
}